# 「小林 coding - 图解 MySQL」学习笔记

## 基础

### 执行一条 SQL 查询语句，期间发生了什么？

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

### MySQL 一行记录是怎么存储的？

> 以下是 InnoDB 存储引擎的实现

#### MySQL 的数据存放在哪里？

一个数据库在文件系统中对应一个与之同名的文件夹，其中包含：

- `db.opt` - 数据库配置文件
- `tb_name.frm` - 表结构文件，存放表的元信息，主要包含表结构定义
- `tb_name.ibd` - 独占表空间文件，存放表中的数据

#### 表空间文件的结构是什么样的？

表空间由段（segment）、区（extent）、页（page）、行（row）组成。

-----插图-----

1. 行

   数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

2. 页

   数据是按页为单位来读写的，页的大小默认是 16KB。

3. 区

   B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机 I/O，随机 I/O 是非常慢的。

   解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。

   那具体怎么解决呢？

   在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。

4. 段

   表空间是由各个段组成的，段是由多个区组成的。段一般分为数据段、索引段和回滚段等。

   - 索引段：存放 B + 树的非叶子节点的区的集合；
   - 数据段：存放 B + 树的叶子节点的区的集合；
   - 回滚段：存放的是回滚数据的区的集合

#### Compact 行格式长什么样？

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

-----插图-----

1. 额外信息

   - 变长字段长度列表 - 记录每个变长字段实际使用的字节数量
   - NULL 值列表 - 记录每个允许 NULL 的字段是否是 NULL，每个允许 NULL 的字段对应一个二进制位，真实数据部分不含 NULL 值字段
   - 头信息 - `delete_mask`、`next_record` 等

   > 变长字段长度列表和 NULL 值列表都不是必需的，只有含有变长字段或允许 NULL 的字段时才存在。

2. 真实数据

   - row_id

     非必需，占用 6 字节。如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。

   - trx_id

     必需，占用 6 字节，表示这个数据是由哪个事务生成的。

   - roll_pointer

     必需，占用 7 字节，记录上一个版本的指针。

#### varchar(n) 中的 n 最大为多少？

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，所有字段 + 变长字段长度列表数 +  NULL 值列表 <= 65535。

#### 行溢出后是怎么处理的？

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

## 索引

### 索引是什么

索引是用于快速查询数据的数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在

### 索引的分类

- 按「数据结构」分类：

  - B+ Tree 索引
  - Hash 索引
  - Full-text 索引

- 按「物理存储」分类：

  - 聚簇索引：索引结构和数据记录一起存放的索引，主键索引就属于聚簇索引。
  - 非聚簇索引：索引结构和数据记录分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。

  > - 主键索引的 B+Tree 的叶子节点存放的是完整的一条记录。
  > - 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是完整的一条记录。
  >
  > 所以，如果查询条件所涉及字段不是主键，会先在相应的二级索引中找到主键值，然后再根据这个主键值，在主键索引中找到相应的记录，完成查询。换言之，其中涉及两次查找索引结构的过程，第二次过程也称为「回表」。

- 按「字段（关键字）特性」分类：

  - 主键索引：以主键为关键字的索引
  - 唯一索引：以 `UNIQUE` 字段为关键字的索引
  - 普通索引：以普通字段为关键字的索引
  - 前缀索引：以字符类型字段的前几个字符为关键字的索引

  > 除了主键索引，其他索引都为二级索引/辅助索引。主键索引是必须的，其他索引不是必须的。

- 按「字段个数」分类：

  - 单列索引：以单个字段为关键字的索引
  - 联合索引：以多个字段为关键字的索引

  > 「最左匹配原则」：如果查询条件中含有联合索引的最左边的一个或多个连续字段时，就可以利用这些字段进行匹配，当遇到范围查找条件时停止。

### 索引下推

对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，在联合索引中查找时只有 a 字段被用到，那在联合索引中找到第一个满足条件 `a > 1` 的记录后，还需要通过遍历的方式判断其他条件（`b = 2`）是否满足。那么，是在联合索引里判断呢？还是回主键索引去判断呢？

- 在 MySQL 5.6 之前，只能一个个回表，到「主键索引」上找出整条记录，再对 b 字段进行比对。
- MySQL 5.6 引入索引下推优化（index condition pushdown)， 可以先对联合索引中包含的字段先进行比对，直接过滤掉不满足条件的记录，减少回表次数。

### 什么时候应该/不应该创建索引

- 经常用于 `where`、`group by`、`order by` 的字段应该创建索引。
- 经常更新的字段不应该创建索引。
- 区分度很低的字段不应该创建索引。
- 表数据太少的时候不应该创建索引。

### 有什么优化索引的方法

- 使用前缀索引

  使用前缀索引可以减少关键字占用的内存空间，从而增加单个非叶子结点中所能包含的关键字数量，使得树更矮，磁盘 I/O 次数更少。

- 使用覆盖索引

  覆盖索引是指查询语句中的字段在二级索引的叶子结点就能找到，不需要回表，从而减少磁盘 I/O 次数。我们可以通过建立联合索引来实现这一点。

- 使用递增的主键

  如果我们使用自增的主键的话，新记录总是在尾部追加，从而减少索引的分裂和重组。

- 防止索引失效

  > 什么情况下会失效？没看懂，后面再了解一下。

### 在 B+ 树中的查找过程是怎么样的

在 B+ 树中，非叶结点仅起索引作用，不含有该关键字对应的记录。记录存放在叶子结点中，记录之间有序排列，以双向链表的形式链接起来。

在一个 B+ 树中查找的过程是这样的：从磁盘中读取根结点，使用二分查找找到下一层结点的磁盘地址，从磁盘中读取该结点，继续使用二分查找找到下一层结点的磁盘地址，以此类推，直到搜索到叶子结点，进而在叶子结点中找到相应的记录。如果查询的字段是二级索引的关键字，则涉及两次在 B+ 树中查找的过程。第一次是在二级索引的 B+ 树中查找关键字对应的主键，再根据这个主键值，回到主键索引的 B+ 树中查找相应的记录。

### 为什么采用 B+ 树实现索引

作为数据库表索引的数据结构，至少要满足两个要求：

- 既能够高效地查找单个元素，也能够高效地进行范围查找。
- 完成查找所需的磁盘 I/O 尽可能地少。

查找快的数据结构，无非就两类：哈希表和有序树。

- 哈希表虽然查找快，但不支持范围查找。
- AVL 树和红黑树虽然查找快，也支持范围查找，但树较高，完成查找所需的磁盘 I/O 较多。
- B 树和 B+ 树都是多叉树，树较矮，完成查找所需的磁盘 I/O 较少。但相比于 B 树，B+ 树具备更少的磁盘 I/O、更稳定的查询效率和更适合于范围查询等优势。

> 在二叉搜索树中完成一次查找，需要访问的结点个数等于树的高度，而访问一个结点通常对应一次磁盘 I/O。因此，要想减少磁盘 I/O，树需要尽量地“矮胖”，换言之，单个结点要尽可能地大，但又不能超过一个数据页的大小，因为在数据库中磁盘 I/O 是以数据页为单位的。因此，在实现中，B+ 树中的每个结点都占用一个数据页。

### 什么情况下会导致索引失效？

> 索引失效是指，对于给定的查询条件，已建立的索引都不能起作用，只能进行全表扫描。

- 使用左模糊匹配或左右模糊匹配（索引中的元素是按字符串前缀排序的）
- 对字段使用函数（除非建立了相应的函数索引）
- 对字段进行算术运算（如 `where id + 1 = 10`）
- 对字段使用隐式类型转换（相当于对字段使用函数）
- 在联合索引中查询，但查询条件未遵循最左匹配原则
- `or` 条件中存在非索引字段

## 事务

### 事务隔离级别是怎么实现的

#### 事务是什么

「事务（Transaction）」是由一个或多个数据库操作组成的序列，这些操作是原子的，要么都执行，要么都不执行。

> 我们在进行多个数据库操作前先开启事务，等所有数据库操作执行完成后，才提交事务。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生发生中断或错误，那么数据库会被回滚到事务开启之前的状态。

#### 事务有哪些特性

事务要具备 4 个特性：

- 原子性：要么都执行，要么都不执行，中途发生中断或错误会进行回滚。
- 持久性：事务处理结束后，对数据的修改是永久性的。
- 隔离性：允许多个事务并发执行，操作共享数据不会出现不一致的情况，每个事务都有一个独立的数据空间，各个并发事务之间是隔离的。
- 一致性：事务处理前后，数据满足完整性约束，数据库保持一致性状态。

> InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？
>
> - 原子性通过 undo log（回滚日志） 来保证。
> - 持久性通过 redo log （重做日志）来保证。
> - 隔离性通过 MVCC（多版本并发控制） 或锁机制来保证。
> - 一致性通过持久性、原子性、隔离性来保证。

#### 并行事务会引发什么问题

MySQL 服务端是允许多个客户端同时连接的，这意味着 MySQL 可能会出现同时处理多个事务的情况。那么在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。

- 脏读：一个事务读到了另一个未提交事务修改过的数据。

- 不可重复读：在一个事务内多次读取同一数据，但前后读到的数据不一致。

- 幻读：某一次的查询操作得到的结果所表征的数据状态无法支撑后续的业务操作。

  > 一个幻读的例子：`select` 某记录是否存在，不存在，准备插入此记录，但执行 `insert` 时发现此记录已存在，无法插入，此时就发生了幻读。

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别从低到高依次是：

- 读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被其他事务看到。
- 读已提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到。
- 可重复读（repeatable read）：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的（InnoDB 引擎的默认隔离级别）。
- 串行化（serializable）：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等待前一个事务执行完成。

> - 在「读未提交」下，可能发生脏读、不可重复读和幻读现象。
> - 在「读已提交」下，可能发生不可重复读和幻读现象。
> - 在「可重复读」下，可能发生幻读现象。
> - 在「串行化」下，三种情况都不可能发生。

#### 重要概念

- MVCC
  MVCC（多版本并发控制）目的是使得并发事务之间的读写操作没有冲突，它的实现主要依赖于 3 个机制：“聚簇索引记录中的两个隐藏字段”、“Read View”以及“undo log 版本链”。

- 当前读
  读取的是最新版本，读取时还要保证其他并发事务不能修改当前记录，会加读写锁。

- 快照读
  读取的是对当前事务可见的版本，有可能是历史版本，不加锁。

- undo log 版本链
  undo log 记录的是反向操作，通过它能够得到记录的历史版本，多个历史版本之间通过链表的形式链接起来。

#### MVCC 是如何工作的

Read View 中有 4 个字段：

- `m_ids` - 当前活跃的事务 ID 集合
- `min_trx_id` - 最小活跃事务 ID
- `max_trx_id` - 预分配事务 ID，当前最大事务 ID + 1（事务 ID 是自增的）
- `creator_trx_id` - 创建者的事务 ID

聚簇索引记录中有 2 个隐藏字段：

- `trx_id` - 最后一次更新该记录的事务 ID
- `roll_ptr` - 回滚指针，指向这条记录的上一个版本

当一个事务创建 Read View 后，根据记录中的 `trx_id` 字段以及 Read View 中的字段，可以知道更新该记录的事务是截至创建 Read View 之时“已提交的事务”，还是“未提交或未启动的事务”，从而判断这条记录对于当前事务是否可见。

> Read View 就像是对数据的一次截屏，截至 Read View 创建之时的最新记录是对当前事务可见的。

具体而言，有以下几种情况：

1. `trx_id` 等于当前事务 ID，说明这条记录就是被当前事务更新的 -> 可见
2. `trx_id` 小于 `min_trx_id`，说明这条记录的更新时间在创建 Read View 之前 -> 可见
3. `trx_id` 大于等于 `max_trx_id`，说明这条记录的更新时间在创建 Read View 之后 -> 不可见
4. `trx_id` 在 `min_trx_id` 和 `mat_trx_id` 之间
   - `trx_id` 在 `m_ids` 中，说明这条记录的更新时间在创建 Read View 之后 -> 不可见
   - `trx_id` 不在 `m_ids` 中，说明这条记录的更新时间在创建 Read View 之前 -> 可见

当得知当前记录不可见时，就会通过回滚指针 `roll_ptr` 找到上一个版本，继续比对。

#### 可重复读是如何工作的

#### 读提交是如何工作的



