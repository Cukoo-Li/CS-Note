# 《C++ Primer》读书笔记-精简版

## 基础



### 函数

- 函数不能定义在另一个函数的内部

- lambda的捕获列表只用于它所在函数中的局部非static变量，对于其他变量，lambda可以直接使用

- bind可以被理解成一个函数适配器，它接收一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表

  ```cpp
  // g是一个有两个参数的可调用对象
  auto g = bind(f, a, b, placeholders::_2, c, placeholders::_1);
  // 生成一个新的可调用对象g，它有两个参数，分别用占位_2和_1表示
  // 传递给g的参数按位置绑定到占位符
  // 调用g(X，Y)会调用f(a, b, Y, c, X)
  ```

## 标准库

- 插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们对一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素
- 通常不对关联容器使用泛型算法
  - 关联容器不能用于修改或重排容器元素的算法，因为其关键字是const的
  - 关联容器只可用于只读取元素的算法。但是，很多这类算法都要搜索序列，而对关联容器使用泛型搜索算法效率是很低的
  - 在实际编程中，如果我们真要对一个关联容器使用泛型算法，要么是将它作为一个源序列，要么是将它作为一个目的位置
- 在手动管理动态内存时，如果在new和delete之间发生异常，且异常未被捕获，则内存就永远不会被释放了。而如果使用智能指针管理动态内存，即使所在函数由于异常退出，智能指针也会被销毁，从而释放资源
- 用new分配一个大小为0的数组是合法的，此时将返回一个合法的非空指针，但此指针不能解引用
- unique_ptr直接支持管理动态数组，支持下标运算
- shared_ptr不直接支持管理动态数组，需要提供自己定义的删除器，但不支持下标运算和算术运算

## 类

### 定义拷贝控制成员

- 析构函数一般都被定义为虚函数
- 拷贝构造函数和拷贝赋值运算符一般是相互依存的，有其一就应有另一
- 需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符
- 可以使用=default来显式地要求编译器生成合成版本
- 可以对任何函数指定=delete。出于实际需求，可以将相应的拷贝控制成员定义为删除的函数
- 大多数拷贝赋值运算符组合了析构函数和拷贝构造函数的工作（释放自身资源、拷贝rhs到自身）
- 除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数
- 可以使用拷贝并交换(copy and swap)技术来定义赋值运算符，这是异常安全的，且能正确处理自赋值

### 移动语义

#### 右值引用

- 左值引用（常规引用）用于绑定左值，而右值引用用于绑定右值
- 右值引用只能绑定到一个将要销毁的对象（临时对象）。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中
- 变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
- 可以通过调用std::move来获得绑定到左值上的右值引用，这意味着承诺：除了对实参赋值或销毁它外，我们将不再使用它

#### 移动构造函数和移动赋值运算符

- 除了完成资源移动，移动构造函数必须保证移后源对象被销毁是无害的
- 移动赋值运算符执行与析构函数和移动构造函数相同的工作，必须正确处理自赋值
- 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
- 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的
- 更新三/五法则：五个拷贝控制成员应该看做一个整体，一般来说，如果定义了其中任何一个，就应该定义所有五个操作
- 依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动

#### 移动迭代器

- 与一般迭代器不同，移动迭代器的解引用运算符生成一个右值引用
- 通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器
- 由于移动迭代器支持正常的迭代器操作，可以将一对移动迭代器传递给算法。特别是，可以将其传递给uninitialized_copy

#### 右值引用和成员函数

- 除了构造函数和赋值运算符以外，根据实际需要，一个成员函数也可以同时提供拷贝和移动版本
- 拷贝版本接受一个指向const的左值引用，移动版本接受一个指向非const的右值引用
- 可以在参数列表后放置一个引用限定符，可以是&或&&，分别指出this可以指向一个左值或者右值
- 类似于const限定符，引用限定符只能用于非static成员函数，且必须同时出现在函数的声明和定义中
- 一个函数可以同时使用const和引用限定，在此情况下，引用限定符必须跟在const限定符之后
- 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

### 类的继承

- C++11允许使用final关键字来指定某个类不能被继承或指定某个函数不能被覆盖
- 对于基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数（在类内部的声明语句之前加上关键字virtual）
- 派生类经常（但不总是）覆盖它继承的虚函数，如果没有覆盖，则会直接继承其在基类中的版本
- 当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- 即使静态类型与动态类型可能不一致，但是我们能使用哪些成员仍然是由静态类型决定的
- 如果某次函数调用使用了默认实参，则实参值由本次调用的静态类型决定
- C++11允许使用override关键字来显式地说明我们覆盖了基类中的虚函数，这样可以让编译器为我们发现一些错误
- 可以使用作用域运算符来回避虚函数的机制，指定执行虚函数的某个特定版本
- 可以通过在类内部的虚函数声明语句处（分号之前）书写=0，将一个虚函数说明为纯虚函数（也称为抽象函数）
- 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类，不能（直接）创建一个抽象基类的对象
- 通过使用using声明，可以改变派生类继承的某个名字的访问级别，前提是该名字是派生类可访问的
- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 当派生类定义了拷贝和移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象
- 在默认情况下，基类的默认构造函数初始化对象的基类部分。要想使用别的构造函数，需要在初始值列表中显式地调用该构造函数
- 析构函数只负责销毁派生类自己分配的资源
- 一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数
- 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们
- 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句

## 模板

### 定义模板

#### 函数模板

- 当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参
- 一个非类型参数表示一个值而非一个类型，我们通过一个特定的类型名而非关键字`class`或`typename`来指定非类型参数
- 在模板定义内，非类型参数是一个常量值，一个常见的用途是指定数组大小
- 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用
- 绑定到整型非类型参数的实参必须是一个常量表达式
- 绑定到指针或引用非类型参数的实参必须具有静态的生存期（不能是动态对象或局部非static对象）
- 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此函数模板的头文件通常既包括声明也包括定义

#### 类模板

- 编译器不能为类模板推断模板实参，我们必须在类模板名后的尖括号中显式提供模板实参列表
- 成员函数只有在被用到时才进行实例化，由于这一特性的存在，即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类

#### 模板参数

- 假定`T`是一个模板类型参数，当编译器遇到类似`T::mem`这样的代码时，它不会知道`mem`是一个类型成员还是一个static数据成员
- 默认情况下，C++假定通过作用域运算符访问的名字不是类型
- 如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型（使用关键字`typename`，不能是`class`）

#### 成员模板

- 一个类可以包含本身是模板的成员函数，这种成员被称为成员模板
- 成员模板不能是虚函数

#### 控制实例化

当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个目标文件中。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在C++11中，我们可以通过显式实例化来避免这种开销。

```cpp
// 实例化声明与定义
extern template class Blob<string>;				// 声明
template int compare(const int&, const int&);	// 定义
```

当编译器遇到extern模板声明时，它不会在文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序的其他位置有该实例化的一个非extern声明（实例化定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前。

- 实例化定义会实例化所有成员

  当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。

## 代码风格指南

- 如果不需要改变实参，尽量使用常量引用作为形参，常量引用能接收的实参类型更广泛