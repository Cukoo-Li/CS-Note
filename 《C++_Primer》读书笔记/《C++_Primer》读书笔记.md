# 《C++ Primer》读书笔记

## C++基础

### 变量和基本类型

#### 基本数据类型

包括算术类型和空类型(`void`)。

##### 算术类型

算术类型的尺寸在不同机器上有所差别，C++标准只对不同算术类型的尺寸的最小值进行了规定，允许编译器赋予这些类型更大的尺寸。

| 类型        | 含义           | 最小尺寸     | 64位计算机 |
| ----------- | -------------- | ------------ | ---------- |
| bool        | 布尔类型       | 未定义       | 8位        |
| char        | 字符型         | 8位          | 8位        |
| wchar_t     | 宽字符型       | 16位         | 16位       |
| char16_t    | Unicode字符    | 16位         | 16位       |
| char32_t    | Unicode字符    | 32位         | 32位       |
| short       | 短整型         | 16位         | 16位       |
| int         | 整型           | 16位         | 32位       |
| long        | 长整型         | 32位         | 32位       |
| long long   | 长整型         | 64位         | 64位       |
| float       | 单精度浮点数   | 6位有效数字  | 32位       |
| double      | 双精度浮点数   | 10位有效数字 | 64位       |
| long double | 扩展精度浮点数 | 10位有效数字 |            |

##### 类型转换

- 非布尔类型的算术值 -> 布尔类型，0为`false`，非0为`true`。
- 整型 -> 浮点类型，浮点数的尾数部分用于表示整型数的有效数字，因此当整型数的有效位数过多时，可能会损失精度。
- 超出表示范围的数 -> 无符号类型，结果是初始值对无符号类型表示数值总数取模后的余数。
- 超出表示范围的数 -> 带符号类型，结果是未定义的。
- 当一个算术表达式中既含有无符号数，又有有符号整型数，且无符号数的尺寸大于等于有符号数的尺寸时，有符号数会被转换成无符号数。

##### 字面值常量

- 整型字面值。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值可能是带符号的也可能是无符号的。
- 浮点型字面值。默认情况下是`double`。
- 字符型字面值。由单引号括起来的一个字符，字符也可以用`\x`十六进制数或`\`八进制数来表示。
- 字符串字面值。由双引号括起来的零个或多个字符，它本质上是一个字符数组，且编译器在结尾处会添加一个空字符(`'\0'`)，因此实际长度比内容多1。
- 布尔类型字面值（`true`和`false`）
- 指针字面值（`nullptr`）

#### 变量

- 变量提供一个具有名字的、可供程序操作的存储空间。
- 对象是指一块能存储数据并具有某种类型的内存空间。
- 对C++程序员来说，“变量”和“对象”一般可以互换使用。

##### 变量定义

- 一条定义语句 = 一个数据类型 + 一个声明符列表（每个声明符命名了一个变量并指定该变量为与数据类型有关的某种类型）
- 定义：规定变量的类型和名字，并开辟存储空间。
- 初始化：创建变量时赋予其一个初始值。
- 赋值：把对象的当前值擦除，以一个新的值来替代。
- 默认初始化：如果定义变量时没有指定初值，则变量被默认初始化，默认值由变量类型决定，同时定义变量的位置也会对此有影响。

##### 变量声明

声明：仅规定变量的类型和名字，不开辟存储空间。

##### 标识符

- 不能连续出现两个下划线
- 不能以下划线紧连大写字母开头
- 定义在函数体外的标识符不能以下划线开头

##### 变量的作用域

变量的作用域始于变量的声明语句，以声明语句所在的作用域末端结束。

#### 复合类型

复合类型是指基于其他类型定义的类型。C++有几种复合类型，本章将介绍其中的两种：引用和指针。

##### 引用

- 引用即别名，引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。
- 引用必须初始化，且一旦初始化完成，引用将和它的初始值对象一直绑定在一起，无法让引用重新绑定到另外一个对象。
- 因为引用本身不是一个对象，所以不能定义引用的引用。

##### 指针

- 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无需在定义时赋初值，如果没有被初始化，指针将拥有一个不确定的值。
- 指针的值应属4种状态：指向一个对象；指向紧邻对象所占空间的下一个位置；空指针；无效指针（其他值）。
- 如果指针指向了一个对象，则允许使用解引用操作符(`*`)来访问该对象。
- `void*`是一种特殊的指针类型，可以用于存放任意对象的地址。

```c++
// 生成空指针的方法
int *p1 = nullptr;  // 推荐使用
int *p2 = 0;
int *p3 = NULL;  // 需要#include cstdlib，尽量避免使用

// 指向指针的引用
int i = 42;
int *p = nullptr;
int *&r = p;  // r是一个对指针p的引用
r = &i;  // r引用了指针p，因此给r赋值&i就是令指针p指向i
*r = 0;  // 解引用r得到i，也就是p指向的对象，将i的值改为0
```

#### const限定符

- 用`const`对变量的类型加以限定，可以将其定义为一个常量对象，任何试图为`const`对象赋值的行为都将引发错误
- 因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化

默认情况下，`const`对象被设定为仅在文件内有效。当多个文件中出现了同名的`const`变量时，其实等同于在不同文件中分别定义了独立的变量。某些时候有这样一种`const`变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量，我们想只在一个文件中定义`const`，而在其他多个文件中声明并使用它。解决办法是，对于`const`变量不管是声明还是定义都添加`extern`关键字，这样只需定义一次就可以了。

##### const的引用

- 把引用绑定在`const`对象上即为对常量的引用，简称常量引用。
- 与普通引用不同的是，常量引用不能用于修改它所绑定的对象。

```c++
const int ci = 1024;
const int &r1 = ci;  // 正确：引用及其对应的对象都是常量
int &r2 = ci;  // 错误：试图让一个非常量引用指向一个常量对象
```

一般来说，引用的类型必须与其所引用对象的类型一致，但是有两个例外。其一是**在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可**。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。

```c++
int i = 42;
const int &r1 = i;  // 正确
const int &r2 = 43;  // 正确
const int &r3 = r1 * 2;  // 正确
int &r4 = r1 * 2;  // 错误
```

要理解这种例外情况的原因，需要弄清楚当一个常量引用被绑定到另外一种类型上时实际发生了什么。

```cpp
double dval = 3.14;
const int &ri = dval;
```

此处`ri`引用了一个`int`型的数。对`ri`的操作应该是整数运算，但`dval`却是一个双精度浮点数而非整数。因此为了确保让`ri`绑定一个整数，编译器把上述代码变成了如下形式：

```cpp
const int temp = dval;  // 由双精度浮点数生成一个临时的整型常量
const int &ri = temp;  // 让ri绑定这个临时量
```

值得注意的是，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因此，当常量引用所绑定的对象不是常量时，虽然不能通过常量引用修改该对象，但是可以通过其他途径修改。

##### 指针和const

1. 指向常量的指针

   - 与引用一样，指向常量的指针不能用于修改它所指向的对象。要想存放常量对象的地址，只能使用指向常量的指针。
   - 一般来说，指针的类型必须与其所指对象的类型一致，但是有两个例外，其一是允许一个指向常量的指针指向一个非常量对象。
   - 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

2. 常量指针

   - 指针是对象而引用不是，因此允许把指针本身定为常量，称为常量指针。
   - 常量指针必须初始化，而且一旦初始化完成，其值（地址）就不能改变了。
   - 把`*`放在`const`关键字之前用以说明指针本身是一个常量。

   ```cpp
   int errNumb = 0;
   int *const curErr = &errNumb;  // curErr将一直指向errNumb
   const double pi = 3.14;
   const double *const pip = &pi;  // pip是一个指向常量对象的常量指针
   ```

##### 顶层const

- 指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指的是不是一个常量是两个相互独立的问题。
- 顶层`const`表示指针本身是一个常量，底层`const`表示指针所指的对象是一个常量。
- 由于用于声明引用的`const`都表示引用所绑定的对象是一个常量，因此用于声明引用的`const`都是底层`const`

##### 常量表达式

- 常量表达式是指值不会改变并且在编译阶段就能得到计算结果的表达式。
- 字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式。

#### 处理类型

##### 类型别名

```cpp
typedef double wages;  // wages是double的同义词
typedef wages base, *p;  // base是double的同义词，p是double*的同义词
// C++11新标准
using SI = Sales_item;  // SI是Sales_item的同义词

// 指针、常量和类型别名
typedef char *pstring;
const pstring cstr = 0;  // cstr是指向char的常量指针
const pstring *ps;  // ps是一个指针，它指向的对象是指向char的常量指针
```

##### auto类型说明符

- 编程时常常需要把表达式的值赋给变量，这就需要在声明变量的时候清楚地知道表达式的类型，但是要做到这一点并不容易，有时甚至做不到
- C++11新标准引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型
- 与原来那些值对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推断变量的类型
- 使用auto也能在一条语句中声明多个变量，但因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型必须一样
- 编译器推断出来的aotu类型有时候和初始值不完全一样，编译器会适当地改变结果类型使其更符合初始化规则
  - 当引用被用作初始值时，编译器以引用对象的类型作为auto的类型
  - auto一般会忽略掉顶层const，同时底层const则会保留下来
  - 如果希望推断出的auto类型是一个顶层const，需要明确指出
  - 对常量对象取地址是一种底层const
  - 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留

##### decltype类型说明符

- 有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量
- C++11新标准引入类型说明符decltype，它的作用是返回表达式的数据类型，不实际计算表达式的值
- decltype处理顶层const和引用的方式与auto不同，如果表达式是一个变量，则会返回该变量的类型（包括顶层const和引用在内）

```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  // x的类型是const int
decltype(cj) y = x;  // y的类型是const int&，y绑定到变量x
decltype(cj) z;  // 错误：z是一个引用，必须初始化
```

- 值得注意的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外
- 如果表达式的内容是解引用操作，则decltype将得到引用类型（这是不是说明*p实际上是一个引用？）

```cpp
int i = 42, *p = &i, &r = i;
decltype(*p) c;  // 错误：c是int&，必须初始化
decltype(r + 0) b;  // 正确：加法的结果是int，因此b是一个int
```

有一种情况需要特别注意：如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型
（注：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果i是int，则表达式i=x的类型是int&）

```cpp
int i = 42;
decltype((i)) d;  // 错误：d是int&，必须初始化
decltype(i) e;  // 正确：e是一个int
```

#### 自定义数据结构

- C++语言允许用户以类的形式自定义数据结构(struct, class)
- 类一般写在头文件中，且文件名与类名保持一致
- 为了有效防止头文件被重复包含的发生，需要使用到头文件保护符
- 头文件不应包含using声明

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
/*
    头文件内容
*/
#endif
```

### 字符串、向量和数组

#### 标准库类型string

##### 定义和初始化string对象

1. 拷贝初始化

   用等号(=)初始化一个变量

   ```cpp
   string s1;  // 默认初始化，s1是一个空字符串
   string s2 = s1;
   string s3 = "cukoo";
   ```

2. 直接初始化

   调用构造函数

   ```cpp
   string s1;
   string s2(s1);
   string s3("cukoo");
   string s4(10, 'c');
   ```

##### string对象上的操作

| 操作           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| os << s        | 将s写到输出流os当中，返回os                                  |
| is >> s        | 从is中读取字符串（自动忽略开头的空白符）赋给s，字符串以空白符分隔，返回is |
| getline(is, s) | 从is中读取一行（保留输入时的空白符）赋给s，返回is            |
| s.empty()      | s为空返回true，否则返回false                                 |
| s.size()       | 返回s中字符的个数（string::size_type类型，一种无符号类型）   |
| s[n]           | 返回s中第n个字符的引用，位置n从0计起                         |
| s1 + s2        | 返回s1和s2连接后的结果（加号的两侧至少有一个是string对象）   |
| s1 = s2        | 用s2的副本代替s1中原来的字符                                 |
| s1 == s2       | 判断s1和s2中所含字符是否完全一样                             |
| <, <=, >, >=   | 利用字符在字典中的顺序进行比较                               |

##### 处理string对象中的字符

在cctype头文件中定义了一系列标准库函数用于探索字符的特性

| 函数        | 含义                                         |
| ----------- | -------------------------------------------- |
| isalnum(c)  | 是否为字母或数字                             |
| isalpha(c)  | 是否为字母                                   |
| iscntrl(c)  | 是否为控制字符                               |
| isdigit(c)  | 是否为数字                                   |
| isgraph(c)  | 是否不是空格但可打印                         |
| islower(c)  | 是否为小写字母                               |
| isprint(c)  | 是否为可打印字符                             |
| ispunct(c)  | 是否为标点符号                               |
| isspace(c)  | 是否为空白符（空格、制表、回车、换行、进纸） |
| isupper(c)  | 是否为大写字母                               |
| isxdigit(c) | 是否是十六进制数字                           |
| tolower(c)  | 转为小写字母                                 |
| toupper(c)  | 转为大写字母                                 |

遍历string中字符的方式

1. 范围for

   ```cpp
   string s = "cukoo";
   // 定义副本
   for (auto c : s) {
       cout << c << endl;
   }
   // 定义引用
   for (auto &c : s) {
       c = toupper(c);
   }
   ```

2. 普通for

   ```cpp
   string s = "cukoo";
   for (decltype(s.size()) i = 0; i != s.size(); ++i) {
       cout << s[i] << endl;
   }
   ```

#### 标准库类型vector

- vector是基于动态数组来实现的
- vector表示对象的集合，其中所有的对象类型都相同，且每个对象都有一个与之对应的索引
- C++既有类模板，也有函数模板，其中vector是一个类模板
- 模板本身不是类或函数，可以将其看作是为编译器生成类或函数编写的一份说明
- 编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化为何种类型

```cpp
vector<int> ivec;  // 保存int类型的对象
vector<Sales_item> Sales_vec;  // 保存Sales_item类型的对象
vector<vector<string>> file;  // 该vector的元素是vector<string>类型的对象
```

##### 定义和初始化vector对象

| 定义语句                   | 说明                                                    |
| -------------------------- | ------------------------------------------------------- |
| vector\<T> v1              | v1是一个空vector，它的潜在元素是T类型的，执行默认初始化 |
| vector\<T> v2(v1)          | v2中包含有v1所有元素的副本                              |
| vector\<T> v2 = v1         | 同上                                                    |
| vector\<T> v3(n, val)      | v3包含了n个重复的元素，每个元素的值都是val              |
| vector\<T> v4(n)           | v4包含了n个重复的元素，每个元素执行默认初始化           |
| vector\<T> v5{a,b,c...}    | v5包含了初始值个数的元素，每个元素被赋予相应的初始值    |
| vector\<T> v5 = {a,b,c...} | 同上                                                    |

##### vector对象上的操作

| 操作                | 说明                                            |
| ------------------- | ----------------------------------------------- |
| v.push_back(t)      | 在尾部添加一个值为t的元素                       |
| v.size()            | 返回元素个数（vector<元素类型>::size_type类型） |
| v.empty()           | 是否为空                                        |
| v[n]                | 返回v中第n个元素的引用                          |
| v1 = v2             | 用v2中的元素的拷贝替换v1中的元素                |
| v1 = {a, b, c, ...} | 用列表中元素的拷贝替换v1中的元素                |
| v1 == v2            | 元素数量且对应位置的元素值是否都相同            |
| <, <=, >, >=        | 以字典顺序进行比较                              |

#### 迭代器介绍

- 所有标准库容器以及string都可以使用迭代器
- 类似于指针类型，迭代器也提供了对对象的间接访问，其对象是容器中的元素或者string对象中的字符
- 迭代器有有效和无效之分。有效的迭代器或者指向某一个元素，或者指向容器中尾元素的下一位置；其他情况均属无效

##### 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员

```cpp
auto b = v.begin();  // 返回指向第一个元素的迭代器
auto c = v.end();  // 返回指向尾元素下一位置的迭代器，这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了所有元素
```

特别地，如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器

| 运算           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| *iter          | 返回迭代器iter所指元素的引用                                 |
| iter->mem      | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem     |
| ++iter         | 令iter指向下一个元素                                         |
| --iter         | 令iter指向上一个元素                                         |
| iter += n      | 令iter向前移动n个元素                                        |
| iter -= n      | 令iter向后移动n个元素                                        |
| iter1 - iter2  | 返回两个迭代器的距离(类型是名为difference_type的带符号整型数) |
| iter1 == iter2 | 是否指向同一个元素                                           |
| iter1 != iter2 | 是否指向不同的元素                                           |
| >、>=、<、<=   | 比较迭代器所指向的位置大小                                   |

- 迭代器的类型是iterator或const_iterator，前者可读可写，后者只可读不可写
- 如果对象是常量，那么只能使用const_iterator，其begin和end成员返回的也是const_iterator
- 可以通过cbegin和cend成员得到const_iterator
- 任何一种可能改变对象容量的的操作，都会使该对象的迭代器失效

#### 数组

- 与vector类似，数组也是存放类型相同的对象的容器
- 与vector不同的是，数组的大小不能改变，性能更好，但灵活性差

##### 定义和初始化内置数组

- 数组的维度也属于数组类型的一部分

- 数组的维度在编译的时候应该是已知的，也就是说，维度必须是一个常量表达式

- 定义数组时必须指定数组的类型，不允许用auto

  ```cpp
  unsigned cnt = 42;  // 不是常量表达式
  constexpr unsigned sz = 42;   // 常量表达式
  int arr[10];   // 含有10个整数的数组
  int *parr[sz];   // 含有42个整型指针的数组
  string bad[cnt];  // 错误：cnt不是常量表达式
  string strs[get_size()];  // 当get_size是constexpr时正确，否则错误
  ```

- 可以对数组的元素进行列表初始化，此时允许忽略数组的维度

- 如果指明了维度，那么初始值的数量不能超过指定的大小

- 如果初始值的数量小于维度，则用提供的初始值初始化靠前的元素，剩下的元素被默认初始化

  ```cpp
  const unsigned sz = 3;
  int a1[sz] = {0, 1, 2};
  int a2[] = {0, 1, 2};
  int a3[5] = {0, 1, 2};  // 等价于a3[] = {0, 1, 2, 0, 0}
  string a4[3] = {"hi", "bye"};
  ```

- 对于字符数组，可以用字符串字面值来进行初始化，但此时要注意字符串字面值结尾处的空字符也会被拷贝到字符数组中去

  ```cpp
  char a[3] = "C++";  // 错误：没有空间可存放空字符
  ```

- 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值

- 数组本身就是对象，所以允许定义数组的指针及数组的引用

  ```cpp
  int *ptrs[10];  // ptrs是含有10个整型指针的数组
  int (*Parray)[10] = &arr;  // Parray指向一个含有10个整数的数组
  int (&arrRef)[10] = arr;  // arrRef引用一个含有10个整数的数组
  ```

##### 访问数组元素

- 与vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问
- 使用数组下标时，通常将其定义为size_t类型（被定义于cstddef头文件）

##### 指针和数组

- 在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针

- 换言之，在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

  ```cpp
  string nums[] = {"one", "two", "three"};
  string *p1 = &nums[0];
  string *p2 = nums;  // 等价于p2 = &nums[0]
  ```

- 对数组执行下标运算其实是对指向数组首元素的指针执行下标运算

  ```cpp
  int ia[] = {0,1,2,3,4};
  int i = ia[2];  // ia转换成指向数组首元素的指针
                  // ia[2]得到(ia + 2)所指的元素
  int *p = ia;    // p指向ia的首元素
  i = *(p + 2);   // 等价于i = ia[2]
  ```

- 只要指针指向的是数组的元素（或者是一个尾后指针），都可以执行下标运算

- 内置的下标运算所用的索引值不是无符号类型，这一点与标准库类型vector和string不一样

  ```cpp
  int *p = &ia[2];
  int j = p[1];  // p[1]等价于*(p + 1)，即ia[3]表示的那个元素
  int k = p[-2];  // p[-2]是ia[0]表示的那个元素
  ```

- 当使用数组作为auto变量的初始值时，推断得到的类型是指针而非数组

- 当使用decltype关键字时，上述转换不会发生，decltype(ia)返回类型是由5个整数构成的数组

  ```cpp
  int ia[] = {0,1,2,3,4};
  auto ia2(ia);  // ia2是一个整型指针，指向ia的第一个元素
  decltype(ia) ia3 = {1,2,3,4,5};  // ia3是一个含5个整数的数组
  ```

- 指针也是迭代器，迭代器支持的运算，指针全都支持
- 可以用标准库函数begin和end（被定义于iterator头文件）获得数组的头指针和尾后指针
- 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，定义在cstddef头文件中

##### *C风格字符串

##### *与旧代码的接口

#### 多维数组

严格来说，C++没有多维数组，通常所说的多维数组其实是数组的数组

```cpp
int ia[3][4] = {
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
// 没有标识每行的花括号，与上一个初始化语句是等价的
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
// 显式地初始化每行的首元素
int ia[3][4] = {{0}, {4}, {8}};
```

- 使用下标运算符处理多维数组

  ```cpp
  constexpr size_t rowCnt = 3, colCnt= 4;
  int ia[rowCnt][colCnt];
  for (size_t i = 0; i != rowCnt; ++i)
      for (size_t j = 0; j != colCnt; ++j)
          cout << ia[i][j] << endl;
  ```

- 使用范围for语句处理多维数组

  ```cpp
  for (auto &row : ia)  // 此处如果不声明为引用类型，则推断出来的类型为int*
      for (auto col : row)
          cout << col << endl;
  ```

- 使用指针处理多维数组

  ```cpp
  // p指向二维数组的首元素，也就是说，p指向含有4个整数的数组
  for (auto p = ia; p != ia + rowCnt; ++p)
      // q指向4个整数数组的首元素，也就是说，q指向一个整数
      for (auto q = *p; q != *p + colCnt; ++q)
          cout << *q << endl;
  
  // 使用标准库函数begin和end让上述代码看起来更简洁！
  for (auto p = begin(ia); p != end(ia); ++p)
      for (auto q = begin(*p); q != end(*p); ++q)
          cout << *q << endl;
  ```

使用类型别名可以简化多维数组的指针

### 表达式

表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。

#### 基础

##### 基本概念

- 根据作用于运算对象的数量不同，运算符主要分为一元运算符、二元运算符和三元运算符
- 函数调用也是一种特殊的运算符，它对运算对象的数量没有限制
- 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（在内存中的位置）
- 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值
- 关键字decltype作用于左值会得到一个引用类型

##### 优先级与结合律

##### 求值顺序

- 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序

- 有4种运算符明确规定了运算对象的求值顺序，分别是逻辑与运算符、逻辑或运算符、条件运算符和逗号运算符

- 求值顺序与优先级和结合律无关，如果求值顺序会影响表达式的结果，那么将产生未定义的行为

  ```cpp
  int i = 0;
  cout << i << " " << ++i << endl;		// 未定义的
  ```

#### 算术运算符

- 取余运算结果的符号与被除数相同

#### 逻辑和关系运算符

#### 赋值运算符

#### 递增递减运算符

#### 成员访问运算符

#### 条件运算符

- 条件运算符(?:)允许我们把简单的if-else逻辑嵌入到单个表达式当中
- 形式：cond ? expr1 : expr2
- expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式
- 条件运算符的优先级非常低

#### 位运算符

- 强烈建议仅将位运算符用于处理无符号类型，因为位运算符对于如何处理运算对象的符号位没有明确的规定
- 一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型

#### sizeof运算符

- sizeof运算符返回一条表达式或一个类型名字所占的字节数，满足右结合律，其所得的值是一个size_t类型的常量表达式
- 形式：sizeof (type) 或者 sizeof expr
- sizeof并不实际计算其运算对象的值。因此，在sizeof运算对象中解引用一个无效指针仍然是一种安全的行为
- 对数组执行sizeof运算将得到整个数组所占空间的大小，即此时数组名不会被转换成首元素的地址
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

#### 逗号运算符

- 逗号运算符含有两个运算对象，按照从左向右的顺序依次求值
- 逗号运算符的结果是右侧表达式的值
- 逗号运算符常用于for循环当中

```cpp
someValue ? ++x, ++y : --x, --y;
// 逗号运算符优先级最低，上述语句等价于
(someValue ? ++x, ++y : --x), --y;
```

#### 类型转换

##### 隐式转换

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型（整型提升）
- 在条件表达式中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 对于运算对象为一个无符号类型和一个有符号类型的情形，如果无符号不小于有符号，则转成无符号；如果有符号大于无符号，且无符号类型的所有值都能存在该有符号类型中，则转成有符号，否则转成无符号
- 一般来说，数组转换成指向数组首元素的指针。当数组被用于decltype、&、sizeof、typeid等时，没有上述转换

##### 显式转换

- 形式：cast-name\<type>(expression)
- cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种，指定了执行的是哪种转换
  - static_cast：任何具有明确定义的类型转换，只要不是从底层const转为非底层const，都可以使用static_cast
  - const_cast：只能改变运算对象的底层const
  - reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释（危险）
  - dynamic_cast：见19.2节
- 强烈建议避免使用强制类型转换

#### 运算符优先级表

### 语句

#### 简单语句

#### 语句作用域

#### 条件语句

##### if语句

##### switch语句

#### 迭代语句

##### while语句

##### 普通for语句

##### 范围for语句

##### do while语句

#### 跳转语句

##### break语句

##### continue语句

##### goto语句

#### try语句和异常处理

##### throw表达式和try语句块

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++中，异常处理包括：

- throw表达式

  异常检测部分使用throw表达式来表示它遇到了无法处理的问题，我们说throw引发了异常。

- try语句块

  异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中抛出的异常通常会被某个catch子句处理。

- 一套异常类

  用于在throw表达式和相关catch子句之间传递异常的具体信息。

当异常被抛出时，首先在抛出该异常的函数中搜索匹配的catch子句。如果没有找到，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到，这个函数也被终止，继续在调用它的函数中寻找。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数会导致程序非正常退出。

##### 标准异常

C++标准库定义了一组异常类，用于报告标准库函数遇到的问题

| 异常类名         | 说明                                           |
| ---------------- | ---------------------------------------------- |
| exception        | 最常见的问题                                   |
| runtime_error    | 只有在运行时才能检测出的问题                   |
| range_error      | 运行时错误：生成的结果超出了有意义的值域范围   |
| overflow_error   | 运行时错误：计算上溢                           |
| underflow_error  | 运行时错误：计算下溢                           |
| logic_error      | 程序逻辑错误                                   |
| domain_error     | 逻辑错误：参数对应的结果值不存在               |
| invalid_argument | 逻辑错误：无效参数                             |
| length_error     | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
| out_of_range     | 逻辑错误：使用一个超出有效范围的值             |
| bad_alloc        | 见12.1.2节                                     |
| bad_cast         | 见19.2节                                       |

- exception、bad_alloc和bad_cast类只能使用默认初始化
- 其他异常类型不能使用默认初始化，应该用string对象或者C风格字符串来初始化这些类型的对象
- 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*
- what函数返回的字符串内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串内容

### 函数

#### 函数基础

- 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序
- 形参名是可以选的，如果形参未命名，则意味着函数体内不会使用它
- 参数传递会忽略掉形参的顶层const，因为对于值拷贝来说，有没有顶层const无关紧要
- 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针
- 局部静态对象初始化后直至程序终止才被销毁
- 如果内置类型变量没有显式的初始值，全局变量和局部静态变量将执行值初始化，局部变量将执行默认初始化
- 函数声明（函数原型）不包含函数体，所以也就无须形参的名字。事实上，函数的声明经常省略形参的名字
- 函数声明应该放在头文件中，定义函数的源文件应该把含有函数声明的头文件包含进来
- 函数可以多次声明，但一般只能被定义一次

#### 参数传递

- 当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用

- 当实参的值被拷贝给形参时，我们说这样的实参被值传递或者函数被传值调用

- 如果不需要改变实参，尽量使用常量引用作为形参，常量引用能接收的实参类型更广泛

- 由于数组不能拷贝，因此不能以值传递的方式传递数组

- 以下三个print函数是等价的：每个函数的唯一形参都是const int\*，编译器只检查传入的参数是否是const int\*

  ```cpp
  void print(const int*);
  void print(const int[]);  // 可以看出来，函数的意图是作用于一个数组
  void print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际上不一定
  ```

- 数组是以指针的形式传递给函数的，所以函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息：

  - 使用标记指定数组长度。要求数组本身包含一个结束标记，典型例子是C风格字符串
  - 使用标准库规范。传递指向数组首元素和尾后元素的指针
  - 显式传递一个表示数组大小的形参。

- 也可以用数组的引用作为形参，但这样的函数只能作用于特定维度的数组，可用性有较大限制

- 传递多维数组

  ```cpp
  void print(int (*matrix)[10], int rowSize);
  void print(int matrix[][10], int rowSize);
  ```

- 可以将main函数定义成int main(int argc, char *argv[]) {...}，这样就可以在命令行给main传递参数。第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0

- 如果实参数量未知但是类型相同，可以使用标准库中的initializer_list类型的形参

  - 与vector类似，initializer_list是表示某种特定类型的值的集合
  - 与vector不同的是，initializer_list对象中的元素永远是常量值，不能修改
  - 对象之间的拷贝或赋值会共享元素，不会产生副本

#### 返回类型和return语句

- 返回值用于对函数返回的临时量进行初始化

- 不要返回局部对象的引用或指针

- 函数可以返回花括号包围的值的列表(C++11)

- 允许main函数没有return语句直接结束，编译器会隐式地插入一条返回0的return语句

- 由于数组不能被拷贝，所以函数不能返回数组，但可以返回数组的指针或引用

- 在不使用类型别名的条件下，定义一个返回数组指针的函数，数组的维度必须跟在函数名字后面：int (*func(int i))[10];

- 使用尾置返回类型(C++11)：auto func(int i) -> int(*)[10];

- 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型

  ```cpp
  int odd[] = {1,3,5,7,9};
  int even[] = {0,2,4,6,8};
  // 返回一个指针，该指针指向含有5个整数的数组
  decltype(odd) *arrPtr(int i) {  // 当使用decltype关键字时，数组名不会转换成首元素的地址，因此decltype的结果是一个数组类型
      return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针
  }
  ```

#### 函数重载

- 在同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载(overload)函数
- 编译器会根据传递的实参类型推断应该调用哪一个函数
- 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。如果两个函数的形参列表仅存在顶层const上的区别，属于重复定义，将会报错
- 二义性调用：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时会发生错误

#### 特殊用途语言特性

##### 默认实参

- 默认实参作为形参的初始值出现在形参列表中
- 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值
- 只能省略尾部的实参，因此在设计含有默认实参的函数时，要合理设置形参的顺序
- 多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参
- 如果函数是先声明后定义，默认实参要写在声明中，不写在定义中
- 局部变量不能作为默认实参，全局变量可以
- 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时

##### 内联函数和constexpr函数

- 将函数指定为内联(inline)函数后，编译过程中会将它在每个调用点上“内联地”展开，因此内联函数可以避免函数调用的开销

- 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数

- 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求

- constexpr函数是指能够返回常量表达式的函数，其返回类型及所有形参类型都必须是字面值类型(常量表达式?)，且函数体中必须有且仅有一条return语句（只能干一件事情，就是return）。其实也可以包含其他语句，只要这些语句在运行时不执行任何操作就行

- 在编译阶段，编译器会把对constexpr函数的调用替换成结果值，为了能在编译过程中随时展开，constexpr函数被隐式指定为inline

- 允许constexpr函数的返回值并非一个常量，但这违反了constexpr函数的初衷

- 把内联函数和constexpr函数的定义放在头文件内

  和其他函数不同，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义，但对同一个函数的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中

##### 调试帮助

程序可以包含一些用于调试的代码，这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。

1. assert预处理宏

   - 预处理宏其实是一个预处理变量，它的行为有点类似于内联函数
   - 用法：assert(expr);
   - 如果表达式为假，assert输出信息并终止程序的执行；如果表达式为真，assert什么也不做
   - assert宏常用于检查“不能发生”的条件
   - 可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查

2. NDEBUG预处理变量

   - assert的行为依赖于一个名为NDEBUG的预处理变量的状态

   - 如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查

   - 可以使用一个#define语句定义NDEBUG，从而关闭调试状态

   - 很多编译器都提供了一个命令行选项使我们可以定义预处理变量

   - 可以使用NDEBUG编写自己的条件调试代码

     ```cpp
     void print(const int ia[], size_t size) {
     #ifndef NDEBUG
         // __func__是编译器定义的一个局部静态变量，用于存放函数的名字
         cerr << __func__ << ": array size is " << size << endl;
     #endif
     // ...
     ```

     除了C++编译器定义的\__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字：

     \_\_FILE\_\_存放文件名的字符串字面值

     \_\_LINE__存放当前行号的整型字面值

     \_\_TIME_\_存放文件编译时间的字符串字面值

     \_\_DATE__存放文件编译日期的字符串字面值

     可以使用这些常量在错误信息中提供更多信息

#### 函数匹配

1. 函数匹配的过程

   1. 确定候选函数

      候选函数具备两个特征：

      - 与被调用函数同名

      - 其声明在调用点可见

   2. 确定可行函数

      可行函数具备两个特征：

      - 其形参数量与本次调用提供的实参数量相等

      - 每个实参的类型与对应的形参类型相同，或者能转换成形参类型

   3. 寻找最佳匹配

      基本思想：实参类型与形参类型越接近，匹配得越好

      如果有且仅有一个函数满足下列条件，则匹配成功：

      - 该函数每个实参的匹配都不劣于其他可行函数提供的匹配
      - 至少有一个实参的匹配优于其他可行函数提供的匹配

      如果没有，则编译器将报告二义性调用的错误

   调用重载函数时应该避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

2. 实参类型转换

   为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：

   1. 精确匹配
      - 实参类型和形参类型相同
      - 实参从数组类型或函数类型转换成对应的指针类型
      - 向实参添加或删除顶层const
   2. 通过const转换实现的匹配
   3. 通过类型提升实现的匹配
   4. 通过算术类型转换或指针转换实现的匹配
   5. 通过类类型转换实现的匹配

#### 函数指针

- 函数指针指向的是函数而非对象

- 和其他指针一样，函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定，与函数名无关

- 要想声明一个函数指针，只需要用指针替换函数名即可

  ```cpp
  bool lengthCompare(const string &, const string &);
  bool (*pf)(const string &, const string &);  // pf是一个函数指针，未初始化
  ```

- 当把函数名作为一个值使用时，该函数名自动转换成指针，取地址符可加可不加

- 可以把函数指针当作函数名来调用该函数，解引用操作符可加可不加

- 如果定义了指向重载函数的指针，指针类型必须与重载函数中的某一个精确匹配

- 和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针

- 可以将形参写成函数类型，此时形参看起来是函数类型，实际上是指针类型

  ```cpp
  void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
  // 等价的声明：显式地将形参定义成函数指针
  void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));
  ```

- 类型别名和decltype可以让我们简化使用函数类型和函数指针类型的代码

  - 需要注意的是，使用decltype时，函数名不会转换为函数指针，因此decltype的结果是函数类型

  - ```cpp
    // Func和Func2是函数类型
    typedef bool Func(const string &, const string &);
    typedef decltype(lengthCompare) Func2;
    // FuncP和FuncP2是函数指针
    typedef bool (*Funcp)(const string &, const string &);
    typedef decltype(lengthCompare) *Funcp2;
    // useBigger的等价声明，其中使用了类型别名
    void useBigger(const string &s1, const string &s2, Func);
    void useBigger(const string &s1, const string &s2, FuncP);
    ```

- 和数组类似，虽然不能返回一个函数，但是能返回函数指针。然而，此时必须把返回类型写成指针类型，不能写成函数类型

  ```cpp
  // 不使用类型别名声明一个返回函数指针的函数
  // 方式1：常规方式
  int (*f(int))(int*, int);
  // 按照由内向外的顺序阅读这条声明语句：f有形参列表，所以f是一个函数；f前面有*，所以f返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int
  // 方式2：使用尾置返回类型
  auto f(int) -> int (*)(int*, int);
  ```

### 类

#### 定义抽象数据类型

##### 定义类相关的成员函数

- 成员函数的声明必须在类的内部，它的定义可以在类的外部，在类外部定义的成员的名字必须包含它所属的类名
- 定义在类内部的函数是隐式的inline函数
- 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，this是请求该函数的对象地址（形参this是常量指针，有顶层const）
- 在成员函数参数列表后面添加const关键字，表示this是一个指向常量的指针（提高灵活性），这样的成员函数被称为常量成员函数
- 常量对象，以及常量对象的引用或指针都只能调用常量成员函数，因为传入普通成员函数的this不能指向自身

##### 定义类相关的非成员函数

- 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中

##### 构造函数

- 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数
- 构造函数的名字和类名相同，没有返回类型，不能被声明成const
- 如果没有显式地定义任何构造函数，那么编译器会为我们隐式地定义一个默认构造函数，函数体为空
- 在C++11中，可以通过在参数列表后面写上=default来要求编译器生成构造函数
- 构造函数初始值列表是成员名字的一个列表，每个名字后面紧跟括号或者花括号括起来的成员初始值，不同成员的初始化用逗号隔开
- 构造函数使用类内初始值不失为一种好的选择，这样就不需要在每个构造函数中都写上每个成员变量的初始值了

##### 拷贝、赋值和析构

- 如果不主动定义拷贝、赋值和销毁操作，编译器将替我们生成它们。一般来说，编译器生成的版本将对每个成员都执行拷贝、赋值和销毁操作
- 自定义操作的有关知识在第13章

#### 访问控制与封装

- 可以使用访问说明符加强类的封装性：
  - public的成员可被外部访问
  - private的成员只能在类内部访问
- struct和class的唯一区别：
  - 类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式
  - 如果使用struct关键字，则是public的
  - 如果使用class关键字，则是private的

##### 友元

- 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的友元(friend)
- 如果想把一个函数或一个类作为某个类的友元，只需在类定义内部增加一条以friend关键字开头的函数声明语句或类声明语句即可
- 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果需要调用某个友元函数，必须在友元声明之外再专门对函数进行一次声明。通常把这种声明与类本身放置再同一个头文件中（类的外部）
- 友元函数可以定义在类的内部，但即便如此，也需要在友元声明之外再专门对函数进行一次声明，这样函数才能在相应作用域可见
- 一些编译器允许在尚无友元函数的初始声明的情况下就调用它，但建议还是提供一个独立的函数声明

#### 类的其他特性

##### 类成员再探

- 类型成员
  - 类还可以自定义某种类型在类中的别名
  - 类型成员同样存在访问限制
  - 在类定义中，类型成员必须先定义后使用，这一点与普通成员有所区别
- 可变数据成员
  - 有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内
  - 通过在变量的声明中加入mutable关键字可以将变量指定为可变数据成员
  - 一个可变数据成员永远不会是const，即使它是const对象的成员
  - 一个const成员函数可以改变一个可变成员的值

##### 返回*this的成员函数

- 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用
- 可以对const成员函数进行重载，以提供一个非常量版本的函数。调用时，编译器会根据对象本身是否是常量来决定应该调用哪个版本

##### 类的声明

- 可以仅仅声明类而暂时不定义它，这种声明又称为前向声明(forward declaration)
- 对于一个类来说，在它声明之后定义之前是一个不完全类型(incomplete type)，我们不清楚它到底包含哪些成员
- 不完全类型的使用场景非常有限：可以定义指向这种类型的指针或引用，也可以声明（非定义）以不完全类型作为参数或返回类型的函数
- 对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器无法了解这样的对象需要多少存储空间
- 类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员

#### 类的作用域

- 一个类就是一个作用域
- 在类外部定义类的成员函数时，函数名前需通过作用域运算符指明所属的类名，此后在函数中访问类的成员就不需要再指明类名了
- 如果返回类型是类的类型成员，因为返回类型出现在函数名之前，因此返回类型也需要指明所属的类名
- 编译器依次处理完类中全部声明后才会处理成员函数的定义

#### 构造函数再探

##### 构造函数初始值列表

- 如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化
- 构造函数的初始值有时必不可少：成员是const、引用，或者属于某种未提供默认构造函数的类类型
- 成员初始化的顺序与它们在类定义中的出现顺序一致，与初始值列表中的成员顺序无关

##### 委托构造函数

- C++11扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数(delegating constructor)
- 委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程
- 使用形式是将初始值列表替换为另一个构造函数，从而实现委托

##### 转换构造函数

- C++在内置类型之间定义了几种自动转换规则。同样的，我们也能为类定义隐式转换规则
- 能通过一个实参调用的构造函数定义了一条从参数类型向类类型的隐式转换规则，这种构造函数又称转换构造函数
- 只允许一步类类型转换
- 可以通过将构造函数声明为explicit抑制构造函数定义的隐式转换，在类外部定义时不应重复使用explicit关键字
- 尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数进行强制类型转换

##### 聚合类

- 聚合类(aggregate class)使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。
- 所有成员都是public的
  - 没有定义任何构造函数
  - 没有类内初始值
  - 没有基类，也没有虚函数
- 通过提供一个花括号括起来的成员初始值列表来初始化聚合类的数据成员
  - 初始值顺序必须与声明顺序一致
  - 如果初始值列表中元素少于类的成员数量，则靠后的成员被值初始化
  - 初始值列表的元素个数不能超过类的成员数量

##### 字面值常量类

- 除了算术类型、引用和指针外，某些类也是字面值类型
- 字面值类型的类可能含有constexpr函数成员，这样的成员必须符合constexpr函数的所有要求，它们是隐式const的(C++11)
- 数据成员都是字面值类型的聚合类是字面值常量类
- 如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
  - 数据成员都必须是字面值类型
  - 类必须至少含有一个constexpr构造函数
  - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象
- constexpr构造函数有以下特点：
  - 既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它唯一能拥有的可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的
  - 必须初始化所有数据成员，初始值要么使用constexpr构造函数，要么使用常量表达式

#### 类的静态成员

- 有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联，这样的成员就是类的静态成员
- 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据
- 静态成员函数也不与任何对象绑定在一起，它们不包含this指针，这意味着静态成员函数不能声明成const的
- 在成员的声明之前加上关键字static即可将其指定为静态成员（static关键字只出现在类内部的声明语句中）
- 静态成员的访问方式：①作用域运算符；②使用类的对象、引用或者指针
- 一般来说，我们不能在类的内部初始化静态数据成员。相反的，必须在类的外部定义和初始化每个静态数据成员
- 类似于全局变量，静态数据成员定义在任何函数之外。因此它一旦被定义，就将一直存在于程序的整个生命周期中

## C++标准库

### IO库

C++使用标准库类来处理面向流的输入和输出：

- iostream处理控制台IO
- fstream处理文件IO
- stringstream完成内存string的IO

fstream和stringstream都是继承自iostream的

#### IO类

IO库类型和头文件：

- iostream

  定义了用于读写流的基本类型：

  - istream, wistream 从流读取数据
  - ostream, wostream 向流写入数据
  - iostream, wiostream 读写流

- fstream

  定义了用于读写命名文件的类型：

  - ifstream, wifstream 从文件读取数据
  - ofstream, wofstream 向文件写入数据
  - fstream, wfstream 读写文件

- sstream

  定义了用于读写内存string对象的类型：

  - istringstream, wistringstream 从string读取数据
  - ostringstream, wostringstream 向string写入数据
  - stringstream, wstringstream 读写string

为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。例如wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。宽字符版本的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。例如，头文件fstream定义了ifstream和wifstream类型。

##### IO对象无拷贝或赋值

- 进行IO操作的函数通常以引用方式传递和返回流，不能将形参或返回类型设置为流类型
- 读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的

##### 条件状态

| IO库条件状态      | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| strm::iostate     | strm是一种IO类型。iostate是一种机器相关的类型，提供了表达条件状态的完整功能 |
| strm::badbit      | 100，用于指出流已崩溃                                        |
| strm::failbit     | 010，用于指出一个IO操作失败了                                |
| strm::eofbit      | 001，用于指出流到达了文件结束                                |
| strm::goodbit     | 000，用于指出流未处于错误状态                                |
| s.eof()           | 若流s的eofbit置位，则返回true                                |
| s.fail()          | 若流s的failbit或badbit置位，则返回true                       |
| s.bad()           | 若流s的badbit置位，则返回true                                |
| s.good()          | 若流s处于有效状态，则返回true                                |
| s.clear()         | 将流s中所有条件状态位复位，即将流的状态设置为有效，返回void  |
| s.clear(flags)    | （&，只管0）根据给定的flags标志位，将流s中对应条件状态位复位。flags的类型为strm::iostate。返回void |
| s.setstate(flags) | （\|，只管1）根据给定的flags标志位，将流s中对应条件状态位置位。flags的类型为strm::iostate。返回void |
| s.rdstate()       | 返回流s的当前条件状态，返回值类型为strm::iostate             |

- IO库定义了4个iostate类型的constexpr值，表示特定的位模式
- 这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检测或设置多个标志位
- 如果到达文件结束位置，eofbit和failbit都会被置位
- 将流当作条件使用时，实际上就等价于!s.fail()

##### 管理输出缓冲

- 每个输出流都管理一个缓冲区，用于保存程序读写的数据
- 缓冲机制使得操作系统可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，这可以提升性能
- 导致缓冲刷新（即数据真正写到输出设备或文件）的原因有很多：
  - 程序正常结束
  - 缓冲区满
  - 可以使用操纵符来显式刷新缓冲区（endl:换行并刷新；flush:仅刷新;ends:插入空字符并刷新）
  - 使用unitbuf操纵符告诉流在接下来每次写操作之后都进行一次flush操作，而nounitbuf操纵符则重置流，使其恢复正常的缓冲区刷新机制。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的
  - 一个输入流或输出流可能被关联到另一个输出流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都被关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新
- 如果程序异常终止，输出缓冲区不会被刷新。因此当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印
- tie有两个重载的版本：一个版本不带参数，返回指向当前所关联流对象的指针；另一个版本接受一个指向ostream的指针，关联到此ostream

#### 文件输入输出

除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件

| fstream特有的操作       | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| fstream fstrm;          | 创建一个未绑定的文件流。fstream是头文件fstream中定义的一个类型 |
| fstream fstrm(s);       | 创建一个fstream，并打开名为s(string or char*)的文件，这些构造函数是explicit的 |
| fstream fstrm(s, mode); | 与前一个构造函数类似，但按指定mode打开文件                   |
| fstrm.open(s)           | 打开名为s的文件，并将文件与fstrm绑定                         |
| fstrm.close()           | 关闭与fstrm绑定的文件，并解除绑定（对象销毁时close会自动被调用） |
| fstrm.is_open()         | 返回一个bool值，指出与fstrm绑定的文件是否成功打开且尚未关闭  |

| 文件模式 | 说明                         |
| -------- | ---------------------------- |
| in       | 以读方式打开                 |
| out      | 以写方式打开                 |
| app      | 每次写操作前均定位到文件末尾 |
| ate      | 打开文件后立即定位到文件末尾 |
| trunc    | 截断文件                     |
| binary   | 以二进制方式进行IO           |

- 只有当out也被设定时才可以设定trunc模式
- 只要trunc没被设定，就可以设定app模式
- 在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开
- 以out模式打开的文件默认指定trunc，除非在指定out模式的同时指定app模式或in模式
- ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用
- 可以通过位与操作符对文件模式进行组合

#### string流

除了继承自iostream类型的行为之外，sstream中定义的类型还增加了一些新的成员来管理与流关联的string

| sstream特有的操作 | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| sstream sstrm;    | sstrm是一个未绑定的sstream的对象。sstream是头文件sstream中定义的一个类型 |
| sstream sstrm(s); | sstrm是一个sstream对象，保存string s的一个拷贝，此构造函数是explicit |
| sstrm.str()       | 返回sstrm所保存的string的拷贝                                |
| sstrm.str(s)      | 将string s拷贝到sstrm中                                      |

### 顺序容器

#### 顺序容器概述

| 顺序容器类型         | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| vector               | 可变大小数组。支持快速随机访问。在尾部之外的位置进行插入/删除操作可能很慢 |
| deque                | 双端队列。支持快速随机访问。在头尾位置进行插入/删除操作很快  |
| list                 | 双向链表。只支持双向顺序访问。在任何位置插入/删除操作都很快  |
| forward_list (C++11) | 单向链表。只支持单向顺序访问。在任何位置插入/删除操作都很快  |
| array (C++11)        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| string               | 与vector相似的容器，但专门用于保存字符                       |

- list和forward_list额外内存开销很大
- forward_list没有size操作

- 除非有很好的理由选择其他容器，否则应使用vector

#### 容器库概览

容器类型上的操作形成了一种层次：

- 某些操作是所有容器类型都提供的
- 另外一些操作仅针对顺序容器、关联容器或无序容器
- 还有一些操作仅适用于小部分容器

| 容器操作               | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 类型别名               |                                                              |
| iterator               | 此容器类型的迭代器类型                                       |
| const_iterator         | 可以读取元素，但不能修改元素的迭代器类型                     |
| size_type              | 无符号整型，足够保存此种容器类型最大可能容器的大小           |
| difference_type        | 带符号整型，足够保存两个迭代器之间的距离                     |
| value_type             | 元素类型                                                     |
| reference              | 元素的左值类型；等价于value_type&                            |
| const_reference        | 元素的const左值类型；等价于const value_type&                 |
| 构造函数               |                                                              |
| C c;                   | 默认构造函数，构造空容器（对于array，大小也是其类型的一部分，因此其默认构造不为空） |
| C c1(c2);              | 构造c2的拷贝c1                                               |
| C c(b, e);             | 构造c，将迭代器b和e的指定范围内的元素拷贝到c（array不支持）  |
| C c{a, b, c...};       | 列表初始化c                                                  |
| 赋值与swap             |                                                              |
| c1 = c2                | 将c1中的元素替换为c2中的元素                                 |
| c1 = {a, b, c...}      | 将c1中的元素替换为列表中的元素（array不支持）                |
| a.swap(b)              | 交换a和b的元素                                               |
| swap(a, b)             | 与a.swap(b)等价                                              |
| 大小                   |                                                              |
| c.size()               | c中的元素数目(forward_list不支持)                            |
| c.max_size()           | c可保存的最大元素数目                                        |
| c.empty()              | 是否为空                                                     |
| 添加/删除元素          | （在不同容器中，这些操作的接口都不同；array不支持）          |
| c.insert(args)         | 将args中的元素拷贝进c                                        |
| c.emplace(inits)       | 使用花括号初始化构造c中的一个元素                            |
| c.erase(args)          | 删除args指定的元素                                           |
| c.clear()              | 删除c中的所有元素，返回void                                  |
| 关系运算符             |                                                              |
| ==, !=                 | 所有容器都支持相等（不等）运算符                             |
| <, <=, >, >=           | 关系运算符（无序关联容器不支持）                             |
| 获取迭代器             |                                                              |
| c.begin(), c.end()     | 返回指向c的首元素和尾元素之后位置的迭代器                    |
| c.cbegin(), c.cend()   | 返回const_iterator                                           |
| 反向容器的额外成员     | （forward_list不支持）                                       |
| reverse_iterator       | 按逆序寻址元素的迭代器                                       |
| const_reverse_iterator | 不能修改元素的逆序迭代器                                     |
| c.rbegin(), c.rend()   | 返回指向c的尾元素和首元素之前位置的迭代器                    |
| c.crbegin(), c.crend() | 返回const_reverse_iterator                                   |

##### 迭代器

| 迭代器支持的操作 | 说明                                                     |
| ---------------- | -------------------------------------------------------- |
| *iter            | 返回迭代器iter所指元素的引用                             |
| iter->mem        | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem |
| ++iter           | 令iter指向下一个元素                                     |
| --iter           | 令iter指向上一个元素                                     |
| iter1 == iter2   | 是否指向同一个元素                                       |
| iter1 != iter2   | 是否指向不同的元素                                       |

- forward_list迭代器不支持递减运算符(--)

| 迭代器支持的运算 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| iter += n        | 令iter向前移动n个元素                                        |
| iter -= n        | 令iter向后移动n个元素                                        |
| iter1 - iter2    | 返回两个迭代器的距离(类型是名为difference_type的带符号整型数) |
| >、>=、<、<=     | 比较迭代器所指向的位置大小                                   |

- 迭代器支持的运算只适用于string、vector、deque和array的迭代器，因为它们都支持随机快速访问

##### 容器类型成员

- size_type
- iterator、const_iterator
- reverse_iterator、const_reverse_iterator
- difference_type
- value_type
- reference、const_reference

##### 容器定义和初始化

- 每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器

- 只有顺序容器（不包括array）的构造函数才能接受容器大小参数

- 将一个新容器创建为另一个容器的拷贝的方法有两种：

  1. 直接拷贝整个容器

     两个容器的类型及其元素类型必须匹配

  2. 拷贝由一个迭代器对指定的元素范围（array不支持）

     容器类型可以不同，且元素类型也可以不同，元素类型之间只要能转换即可

- 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小

- 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制

##### 赋值和swap

| 容器赋值运算     | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| c1 = c2          | 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型   |
| c = {a, b, c...} | 将c中元素替换为初始化列表中元素的拷贝（array不支持）         |
| swap(c1, c2)     | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
| c1.swap(c2)      | 与swap(c1, c2)等价                                           |
| seq.assign(b, e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
| seq.assign(il)   | 将seq中的元素替换为初始化列表il中的元素                      |
| seq.assign(n, t) | 将seq中的元素替换为n个值为t的元素                            |

- assign操作不适用于关联容器和array，允许从一个不同但相容的类型赋值
- 赋值相关运算会导致指向左边容器内部的迭代器、指针和引用失效
- 除array外，swap不对任何元素进行拷贝、删除或插入操作。这意味着，除string外，指向容器的迭代器、指针和引用在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了
- 与其他容器不同，swap两个array会真正交换它们的元素的值。因此，在swap之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换

##### 关系运算符

- 容器的关系运算符是使用元素类型的关系运算符来完成比较的

#### 顺序容器操作

##### 向顺序容器添加元素

| 向顺序容器添加元素的操作 | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| c.push_back(t)           | 在c的尾部创建一个值为t的元素                                 |
| c.emplace_back(args)     | 在c的尾部创建一个由args创建的元素                            |
| c.push_front(t)          | 在c的头部创建一个值为t的元素                                 |
| c.emplace_front(args)    | 在c的头部创建一个由args创建的元素                            |
| c.insert(p, t)           | 在迭代器p指向的元素之前创建一个值为t的元素。返回指向新元素的迭代器 |
| c.emplace(p, args)       | 在迭代器p指向的元素之前创建一个由args创建的元素。返回指向新元素的迭代器 |
| c.insert(p, n, t)        | 在迭代器p指向的元素之前插入n个值为t的元素。返回指向第一个新元素的迭代器；若n为0，则返回p |
| c.insert(p, b, e)        | 在迭代器p指向的元素之前插入由迭代器b和e指定的范围内的元素。b和e不能指向c中的元素。返回指向第一个新元素的迭代器；若范围为空，则返回p |
| c.insert(p, il)          | il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向第一个新元素的迭代器；若列表为空，则返回p |

- array不支持上述操作
- forward_list有自己专有版本的insert和emplace
- forward_list不支持push_back和emplace_back
- vector和string不支持push_front和emplace_front
- 向一个vector、string或deque插入元素会使所有指向容器的迭代器、指针和引用失效
- 调用emplace成员函数时，是将参数传递（转发）给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间中直接构造元素

##### 访问元素

| 在顺序容器中访问元素 | 说明                                                      |
| -------------------- | --------------------------------------------------------- |
| c.back()             | 返回c中尾元素的引用。若c为空，函数行为未定义              |
| c.front()            | 返回c中首元素的引用。若c为空，函数行为未定义              |
| c[n]                 | 返回c中下标为n的元素的引用。若索引越界，函数行为未定义    |
| c.at(n)              | 返回下标为n的元素的引用。若索引越界，抛出out_of_range异常 |

- back不适用于forward_list
- at和下标操作只适用于string、vector、deque和array，因为它们都提供随机快速访问

##### 删除元素

| 顺序容器的删除操作 | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| c.pop_back()       | 删除c中尾元素。若c为空，则函数行为未定义。函数返回void       |
| c.pop_front()      | 删除c中首元素。若c为空，则函数行为未定义。函数返回void       |
| c.erase(p)         | 删除迭代器p所指定的元素，返回一个指向被删除元素之后位置的迭代器 |
| c.erase(b, e)      | 删除迭代器b和e所指定范围内的元素。返回指向最后一个被删元素之后位置的迭代器 |
| c.clear()          | 删除c中的所有元素                                            |

- forward_list有特殊版本的erase
- forward_list不支持pop_back；vector和string不支持pop_front
- 删除deque中除首尾位置之外的任何元素都会使所有迭代器、指针和引用失效
- 指向vector或string中删除点之后位置的迭代器、指针和引用都会失效

##### 特殊的forward_list操作

| 在forward_list中插入或删除元素的操作 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| lst.before_begin()                   | 返回指向链表首元素之前的迭代器                               |
| lst.cbefore_begin()                  | 返回const_iterator                                           |
| lst.insert_after(p, t)               | 在迭代器p之后的位置插入值为t的元素。返回指向最后一个插入元素的迭代器 |
| lst.insert_after(p, n, t)            | 在迭代器p之后的位置插入n个值为t的元素。返回指向最后一个插入元素的迭代器 |
| lst.insert_after(p, b, e)            | 在迭代器p之后插入b和e指定范围内的元素。返回指向最后一个插入元素的迭代器 |
| lst.insert_after(p, il)              | 在迭代器p之后插入花括号列表内的元素。返回指向最后一个插入元素的迭代器 |
| emplace_after(p, args)               | 使用args在p指定的位置之后创建一个元素。返回指向这个新元素的迭代器 |
| lst.erase_after(p)                   | 删除p指向的位置之后的元素。返回指向被删元素之后的迭代器      |
| lst.erase_after(b, e)                | 删除b和e指定范围内的元素。返回指向被删元素之后的迭代器       |

##### 改变容器大小

| 顺序容器大小操作 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| c.resize(n)      | 调整c的大小为n。缩小容器会导致末尾的元素被丢弃，扩大容器会对新元素进行值初始化 |
| c.resize(n, t)   | 调整c的大小为n。任何新添加的元素都初始化为值t                |

- 如果resize缩小容器，则指向被删除元素的迭代器、指针和引用都会失效
- 对vector、string或deque进行resize可能导致迭代器、指针和引用失效

##### 容器操作可能使迭代器失效

对容器进行添加或删除元素的操作可能会使指向容器元素的迭代器、引用或指针失效。

向容器添加元素后：

- 对于vector或string，如果存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后的元素的迭代器、指针和引用将会失效
- 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的指针和引用不会失效
- 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效

从容器删除元素后：

- 对于vector和string，指向被删元素之前元素的迭代器、指针和引用仍有效
- 对于deque，在首尾之外的任何位置删除元素都会导致迭代器、指针和引用失效；删除尾元素会导致尾后迭代器失效，但其他迭代器、指针和引用不受影响；删除首元素，这些也不会受影响
- 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效

#### vector对象是如何增长的

为了支持快速随机访问，vector将元素连续存储。当vector增长时，如果没有空间容纳新增元素，容器必须分配新的内存空间来保存已有元素和新元素。当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。

| 容器容量管理操作  |                                           |
| ----------------- | ----------------------------------------- |
| c.shrink_to_fit() | 请将capacity()减少为与size()相同大小      |
| c.capacity()      | 不重新分配内存空间的话，c可以保存多少元素 |
| c.reserve(n)      | 分配至少能容纳n个元素的内存空间           |

- shrink_to_fit只适用于vector、string和deque
- capacity和reserve只适用于vector和string
- 调用shrink_to_fit只是一个请求，标准库并不保证退还内存

#### 额外的string操作

##### 构造string的其他方法

| 构造string的其他方法    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| string s(cp, len)       | s是从cp指向的char数组元素开始的len个字符的拷贝               |
| string s(str, pos)      | s是str从下标pos开始的字符的拷贝。若pos>str.size()，抛出异常  |
| string s(str, pos, len) | s是str从下标pos开始的len个字符的拷贝。不管len的值是多少，构造函数至多拷贝到末尾 |

- str是string或const char*
- 通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符停止

##### 子字符串操作

| 子字符串操作     | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| s.substr(pos, n) | 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0；n的默认值为s.size()-pos，即拷贝到末尾 |

##### 改变string的其他方法

| 修改string的操作       | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| s.insert(pos, args)    | 在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器 |
| s.erase(pos, len)      | 删除从位置pos开始的len个字符。如果len被省略，则删除至末尾。返回一个指向s的引用 |
| s.assign(args)         | 将s中的字符替换为args指定的字符。返回一个指向s的引用         |
| s.append(args)         | 将args追加到s。返回一个指向s的引用                           |
| s.replace(range, args) | 删除s中该范围range内的字符，替换为args指定的字符。range是一个下标和一个长度，或者是一对迭代器。返回一个指向s的引用 |
| args可能是下列形式之一 |                                                              |
| str                    | 字符串str                                                    |
| str, pos, len          | str中从pos开始最多len个字符                                  |
| cp, len                | 从cp指向的字符数组的前（最多）len个字符                      |
| cp                     | cp指向的以空字符结尾的字符数组                               |
| n, c                   | n个字符c                                                     |
| b, e                   | 迭代器b和e指定的范围内的字符                                 |
| 初始化列表             | 花括号包围的，以逗号分隔的字符列表                           |

- 并不是每个函数都支持上述所有形式的参数，具体请查阅标准库接口

##### string搜索操作

- string类提供了6个不同的搜索函数，每个函数都有4个重载版本
- string搜索函数返回string::size_type值，表示匹配发生位置的下标
- 如果搜索失败，则返回一个名为string::npos的static成员，其初始值为-1，意味着npos等于任何string最大的可能大小

| string搜索操作            | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| s.find(args)              | 查找s中args第一次出现的位置                                  |
| s.rfind(args)             | 查找s中args最后一次出现的位置                                |
| s.find_first_of(args)     | 在s中查找args中任何一个字符第一次出现的位置                  |
| s.find_last_of(args)      | 在s中查找args中任何一个字符最后一次出现的位置                |
| s.find_first_not_of(args) | 在s中查找第一个不在args中的字符                              |
| s.find_last_not_of(args)  | 在s中查找最后一个不在args中的字符                            |
| args必须是以下形式之一    |                                                              |
| c, pos                    | 从s中位置pos开始查找字符c。pos默认为0                        |
| str, pos                  | 从s中位置pos开始查找字符串str。pos默认为0                    |
| cp, pos                   | 从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0 |
| cp, pos, n                | 从s中位置pos开始查找从指针cp指向的数组元素开始的前n个字符。pos和n无默认值 |

##### compare函数

- 根据s是等于、大于还是小于参数指定的字符串，s.compare返回0、正数或负数

| s.compare的几种参数形式 | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| s2                      | 比较s和s2                                                    |
| pos1, n1, s2            | 将s中从pos1开始的n1个字符与s2进行比较                        |
| pos1, n1, s2, pos2, n2  | 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较  |
| cp                      | 比较s与cp指向的以空字符结尾的字符数组                        |
| pos1, n1, cp            | 将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较 |
| pos1, n1, cp, n2        | 将s中从pos1开始的n1个字符与从指针cp指向的数组元素开始的前n2个字符进行比较 |

##### 数值转换

| string和数值之间的转换 | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| to_string(val)         | 一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升 |
| stoi(s, p, b)          | 返回s的起始子串（表示整数内容）的int数值                     |
| stol(s, p, b)          | 返回s的起始子串（表示整数内容）的long数值                    |
| stoul(s, p, b)         | 返回s的起始子串（表示整数内容）的unsigned long数值           |
| stoll(s, p, b)         | 返回s的起始子串（表示整数内容）的long long数值               |
| stoull(s, p, b)        | 返回s的起始子串（表示整数内容）的unsigned long long数值      |
| stof(s, p)             | 返回s的起始子串（表示浮点数内容）的float数值                 |
| stod(s, p)             | 返回s的起始子串（表示浮点数内容）的double数值                |
| stold(s, p)            | 返回s的起始子串（表示浮点数内容）的long double数值           |

- 通常s中的第一个非空白符必须是符号（+或-）或数字
- 对于将字符串转换为整型值的函数，根据基数不同，s可以包含字母字符，对应大于数字9的数
- 对于将字符串转换为浮点值的函数，s也可以以小数点(.)开头，并可以包含e或E来表示指数部分
- p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为0，即，函数不保存下标
- b表示转换所用的基数，默认值为10

#### 容器适配器

- 标准库定义了三个顺序容器适配器：stack、queue和priority_queue
- 适配器是标准库中的一个通用概念。容器、迭代器和函数都有适配器
- 一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样
- 一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型

| 所有容器适配器都支持的操作和类型 | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| size_type                        | 一种无符号整数类型，足以保存当前类型的最大对象的大小         |
| value_type                       | 元素类型                                                     |
| container_type                   | 实现适配器的底层容器类型                                     |
| A a;                             | 创建一个名为a的空适配器                                      |
| A a(c);                          | 创建一个名为a的适配器，带有容器c的一个拷贝                   |
| 关系运算符                       | 每个适配器都支持所有关系运算符，这些运算符返回底层容器的比较结果 |
| a.empty()                        | 返回是否为空                                                 |
| a.size()                         | 返回a中的元素数目                                            |
| swap(a, b)                       | 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同 |
| a.swap(b)                        | 与swap(a, b)等价                                             |

- 默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的

- 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型

  ```cpp
  vector<int> ivec{1, 2, 3};
  stack<int, vector<int>> ista(ivec);
  ```

- 对于一个给定的适配器，可以使用哪些容器来构造是有限制的：

  - 所有适配器都要求容器具有添加、删除以及访问尾元素的能力，因此不能用array和forward_list来构造适配器
  - stack只要求push_back、pop_back和back操作，因此可以使用deque、list或vector来构造
  - queue要求back、push_back、front和pop_front，因此可以使用deque或list来构造
  - priority_queue要求front、push_back、pop_back以及随机访问能力，因此可以使用deque或vector来构造

1. 栈适配器(stack)

   | stack操作       | 说明                                                 |
   | --------------- | ---------------------------------------------------- |
   | s.pop()         | 删除栈顶元素，但不返回元素值                         |
   | s.top()         | 返回栈顶元素，但不将元素弹出                         |
   | s.push(item)    | 创建一个新元素压入栈顶，该元素通过拷贝或移动item而来 |
   | s.emplace(args) | 创建一个新元素压入栈顶，该元素由args构造             |

2. 队列适配器(queue、priority_queue)

   | queue和priority_queue操作 | 说明                                                         |
   | ------------------------- | ------------------------------------------------------------ |
   | q.pop()                   | 删除首元素，但不返回元素值                                   |
   | q.front()                 | 返回首元素，但不删除该元素。只适用于queue                    |
   | q.back()                  | 返回尾元素，但不删除该元素。只适用于queue                    |
   | q.top()                   | 返回最高优先级元素，但不删除该元素。只适用于priority_queue   |
   | q.push(item)              | 在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item |
   | q.emplace(args)           | 在queue末尾或priority_queue中恰当的位置创建一个元素，其值由args构造 |

   - queue使用一种先进先出的存储和访问策略
   - priority_queue在queue的基础上加入了优先级，新加入的元素会排在所有优先级比它低的已有元素之前
   - 默认情况下，标准库在元素类型上使用<运算符来确定相对优先级

### 泛型算法

- 标准库并未给每个容器添加大量功能，而是提供了一组算法，这些算法中的大多数都独立于任何特定的容器

- 这些算法是通用的（或称泛型的）：它们可用于不同类型的容器和不同类型的元素

- 大多数算法都定义在头文件algorithm中，一些数值泛型算法定义在头文件numeric中
- 算法永远不会执行容器的操作，永远不会改变它们所操作的容器的大小

#### 初识泛型算法

- 标准库提供了超过100个算法。这些算法有一致的结构，理解此结构有助于我们更容易地学习和使用这些算法
- 除了少数例外，标准库算法都对一个范围内的元素进行操作，这个范围总是使用前两个参数来表示，也称“输入范围”
- 理解算法的最基本方法是了解它们是否读取元素、改变元素或是重排元素顺序

##### 只读算法

1. find(b, e, val)

   在输入范围内查找val，返回指向第一个等于给定值val的元素的迭代器，如果找不到则返回e。

2. count(b, e, val)

   返回给定值val在输入范围中出现的次数。

3. accumulate(b, e, ival)

   将初值ival作为求和起点，返回输入范围内元素的总和。ival的类型决定了函数中使用哪个加法运算符以及返回值类型。

4. equal(b1, e1, b2)

   将输入范围中的每个元素与目的序列的对应元素进行比较，相等返回true，否则返回false。目的序列至少与输入范围一样长，元素类型不必一样，只要能用==来比较即可。

5. find_if(b, e, predicate)

   对输入范围内的每个元素调用谓词，返回指向第一个使谓词为真的元素的迭代器，如果不存在这样的元素，则返回e。

6. count_if(b, e, predicate)

   对输入范围内的每个元素调用谓词，返回谓词为真的计数

##### 写容器元素的算法

1. fill(b, e, val)

   将给定值val赋予输入范围中的每个元素。

2. fill_n(b, n, val)

   将给定值val赋予从迭代器b指向的元素开始的n个元素。

3. copy(b1, e1, b2)

   将输入范围中的元素拷贝到目标序列中，返回其目标位置迭代器（递增后）的值。

4. replace(b, e, oval, nval)

   将输入范围中值为oval的元素替换为nval。

- 向目标位置迭代器写入数据的算法假定目标位置(size)足够大，能容纳要写入的元素

- 使用插入迭代器可以保证算法有足够空间(size)来容纳输入数据

- 多个算法都提供所谓的“拷贝”版本，这些版本不会修改输入序列，而是创建一个新序列保存结果

  ```cpp
  // ilst未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42
  replace_copy(ilst.cbengin(), ilst.cend(), back_inserter(ivec), 0, 42);
  ```


##### 重排容器元素的算法

1. sort(b, e)

   利用元素类型的<运算符对输入范围内的元素进行排序。

2. unique(b, e)

   将输入范围内相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。此位置之后的元素仍然存在，但其值是不确定的。

3. stable_sort(b, e)

   利用元素类型的<运算符对输入范围内的元素进行排序，并维持相等元素的原有顺序。

4. partition(b, e, predicate)

   对输入范围内的元素进行划分，使谓词为true的元素排在前面，返回指向最后一个使谓词为true的元素之后的位置的迭代器。

#### 定制操作

- 很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较
- 标准库还为这些算法定义了额外的版本，允许我们提供自己的定义的操作（谓词）来代替默认运算符

##### 谓词

- 谓词(predicate)是一个可调用表达式，其返回结果是一个能用作条件的值
- 标准库算法所使用的谓词分为两类：一元谓词（接受一个参数）和二元谓词（接受两个参数）
- 接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型

##### lambda表达式

- 一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数

- 与函数类似，一个lambda具有返回类型、参数列表和函数体

- 与函数不同，lambda可能定义在函数内部

- lambda表达式形式如下：

  ```cpp
  [capture list] (parameter list) -> return type { function body }
  auto f = [] { return 42; };
  cout << f() << endl;
  ```

  - capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）
  - lambda必须使用尾置返回类型
  - 可以忽略参数列表和返回类型，但必须包含捕获列表和函数体
  - 如果忽略返回类型，lambda根据函数体中的代码推断出返回类型
    - 如果函数体只是一个return语句，则返回类型为返回的表达式的类型
    - 如果函数体包含任何单一return语句之外的内容，则返回类型为void
  - lambda不能有默认参数，因此，lambda调用的实参数目永远与形参数目相等
  - 捕获列表用于指明lambda要访问的它所在函数中的局部变量
  - 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字
  - for_each算法接受一个可调用对象，对输入范围中每个元素调用此对象

##### lambda捕获和返回

- 当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型和对象
- 默认情况下，从lambda生成的类中的数据成员就是lambda所捕获的变量
- 与参数类似，变量的捕获方式也可以是值或引用
- 与参数不同，以值方式被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝
- 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的
- 建议尽量保持lambda的变量捕获简单化：减少捕获的数据量；避免捕获指针或引用
- 隐式捕获：可以在捕获列表中写一个=或&，让编译器以值捕获或引用捕获的方式推断捕获列表
- 可以混合使用隐式捕获和显式捕获，捕获列表中的第一个元素必须是一个&或=，且显式捕获与隐式捕获的捕获方式必须不同
- 可变lambda：默认情况下，lambda不能改变以值方式捕获的变量。如果我们希望能改变它的值，则必须在参数列表之后加上关键字mutable。因此，可变lambda不能省略参数列表

##### 参数绑定

- 如果我们想用函数替换一个捕获局部变量的lambda，可以使用标准库bind函数，它定义在头文件functional中

- 可以将bind函数看作一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表

- bind可以用于给某个可调用对象绑定参数或重新安排其顺序

- 例如，假定f是一个可调用对象，它有5个参数

  ```cpp
  // g是一个有两个参数的可调用对象
  auto g = bind(f, a, b, placeholders::_2, c, placeholders::_1);
  // 生成一个新的可调用对象g，它有两个参数，分别用占位_2和_1表示
  // 传递给g的参数按位置绑定到占位符
  // 调用g(X，Y)会调用f(a, b, Y, c, X)
  ```

- 默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中

- 如果我们希望传递给bind一个对象而不拷贝它，就必须使用标准库ref函数

  - ref返回一个对象，包含给定的引用，此对象是可以拷贝的
  - 标准库中还有一个cref函数，生成一个保存const引用的类对象
  - ref和cref都定义在头文件functional中

#### 再探迭代器

除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。

- 插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素
- 流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的IO流
- 反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器
- 移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们

##### 插入迭代器

插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们对一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

| 插入迭代器操作  | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| it = t          | 在it指定的位置插入值t。不同种类的插入迭代器调用不同的容器操作 |
| *it, ++it, it++ | 这些操作虽然存在，但不会对it做任何事情。每个操作都返回it     |

插入迭代器有三种类型，差异在于元素插入的位置：

- back_inserter - 创建一个使用push_back的插入迭代器

- front_inserter - 创建一个使用push_front的插入迭代器

- inserter - 创建一个使用insert的插入迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器中某个有效位置的迭代器

  ```cpp
  // 如果it1是由inserter生成的迭代器，it2是普通迭代器，两者指向同一个元素
  *it1 = val;
  // 其效果与下面代码一样
  it2 = c.insert(it2, val);
  ++it2;
  ```

  front_insert生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会

##### iostream迭代器

虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。

1. istream_iterator操作

   ```cpp
   // 使用istream_iterator从标准输入读取数据，存入一个vector
   istream_iterator<int> cin_iter(cin);
   istream_iterator<int> eof;
   while (cin_iter != eof)
       vec.push_back(*cin_iter++);
   // 可以将上述程序重写为如下形式，这体现了istream_iterator更有用的地方
   istream_iterator<int> cin_iter(cin), eof;
   vector<int> vec(cin_iter, eof);
   ```

   | istream_iterator操作         | 说明                                                         |
   | ---------------------------- | ------------------------------------------------------------ |
   | istream_iterator\<T> in(is); | in从输入流is读取类型T的值                                    |
   | istream_iterator\<T> end;    | 表示尾后位置                                                 |
   | in1 == in2, in1 != in2       | in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 |
   | *in                          | 返回从流中读取的值                                           |
   | in->mem                      | 等价于(*in).mem                                              |
   | ++in, in++                   | 使用元素类型所定义的>>运算符从输入流中读取下一个值           |

   当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。

2. ostream_iterator操作

   | ostream_iterator操作              | 说明                                                         |
   | --------------------------------- | ------------------------------------------------------------ |
   | ostream_iterator\<T> out(os);     | out将类型为T的值写到输出流os中                               |
   | ostream_iterator\<T> out(out, d); | out将类型为T的值写到输出流os中，每个值后面都输出一个C风格字符串d |
   | out = val                         | 用<<运算符将val写到out所绑定的ostream中。val的类型必须与out可写的类型兼容 |
   | *out, ++out, out++                | 这些运算符虽然存在，但不对out做任何事情，都返回out           |

   ```cpp
   // 使用ostream_iterator输出vecotr中的元素
   ostream_iterator<int> cout_iter(cout, " ");
   for (auto e : vec)
       *out_iter++ = e;
   // *和++不对out_iter做任何事情，可以忽略，换言之，循环可以重写成下面的样子
   for (auto e : vec)
       out_iter = e;
   // 推荐第一种写法，流迭代器的使用与其他迭代器的使用保持一致，方便修改，可读性强
   
   // 可以通过调用copy来打印vec中的元素，这比编写循环更为简单
   copy(vec.begin(), vec.end(), out_iter);
   ```

##### 反向迭代器

- 对于反向迭代器，递增（以及递减）操作的含义会颠倒过来

- 除了forward_list之外，其他容器都支持反向迭代器

- 可以通过调用rbegin、rend、crbegin、crend成员函数来获得反向迭代器

- 虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器

- 反向迭代器需要递减运算符。除了forward_list之外，标准容器上的其他迭代器都支持递减运算符。但是，流迭代器不支持递减运算符

- reverse_iterator的base成员函数返回其对应的普通迭代器

- 反向迭代器和普通迭代器间的关系：

![](./images/upgit_20230616_1686884807.png)


#### 泛型算法结构

- 任何算法的最基本的特性是它要求其迭代器提供哪些操作
- 算法所要求的迭代器操作可以分为5个迭代器类别
- 每个算法都会对它的每个迭代器参数指明须提供哪类迭代器

| 迭代器类别     | 说明                                 |
| -------------- | ------------------------------------ |
| 输入迭代器     | 只读，不写；单遍扫描，只能递增       |
| 输出迭代器     | 只写，不读；单遍扫描，只能递增       |
| 前向迭代器     | 可读写；多遍扫描，只能递增           |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         |
| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |

##### 5类迭代器

1. 输入迭代器(input iterator)

   - 可以读取序列中的元素。输入迭代器必须支持：
     - 用于比较两个迭代器的相等和不相等运算符(==、!=)
     - 用于推进迭代器的前置和后置递增运算符(++)
     - 用于读取元素的解引用运算符(*)；解引用只会出现在赋值运算符的右侧
     - 箭头运算符(->)，即解引用迭代器，并访问对象的成员

   - 输入迭代器只能用于单遍扫描算法；istream_iterator是一种输入迭代器。

2. 输出迭代器(output iterator)

   - 只写而不读元素。输出迭代器必须支持：
     - 用于推进迭代器的前置和后置递增运算符(++)
     - 解引用运算符(*)，只出现在赋值运算符的左侧

   - 输出迭代器只能用于单遍扫描算法；ostream_iterator是一种输出迭代器。

3. 前向迭代器(forward iterator)

   - 可以正向读写序列中的元素
   - 支持输入和输出迭代器的所有操作，而且可以多次读写同一个元素
   - forward_list上的迭代器是前向迭代器

4. 双向迭代器(bidirectionnal iterator)

   - 可以正向/反向读写序列中的元素
   - 支持前向迭代器的所有操作，而且支持前置和后置递减运算符(--)
   - 除forward_list之外，其他标准库容器都提供符合双向迭代器要求的迭代器

5. 随机访问迭代器(random-access iterator)

   - 提供在常量时间内访问序列中任意元素的能力
   - 支持双向迭代器的所有操作，还支持：
     - 用于比较两个迭代器相对位置的关系运算符(<、<=、>、>=)
     - 迭代器和一个整数值的加减运算(+、+=、-、-=)
     - 用于计算两个迭代器距离的减法运算符(-)
     - 下标运算符(iter[n])，与*(iter+n)等价（与指针类似）
   - array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是

##### 算法形参模式

大多数算法具有如下4种形式之一：

- alg(beg, end, other args);
- alg(beg, end, dest, other args);
- alg(beg, end, beg2, other args);
- alg(beg, end, beg2, end2, other args);

##### 算法命名规范

- 接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数

  ```cpp
  unique(beg, end);		// 使用==运算符比较元素
  unique(beg, end, comp); // 使用comp比较元素
  ```

- 接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值，名字后面都附加_if

  ```cpp
  find(beg, end, val);		// 查找输入范围中val第一次出现的位置
  find_if(beg, end, pred); 	// 查找第一个令pred为真的元素
  ```

- 默认情况下，重排元素的算法进行的是本地操作。这些算法提供在名字后面附加一个_copy的版本，将元素写到一个指定的目的位置

  ```cpp
  reverse(beg, end);				// 反转输入范围中元素的顺序
  reverse_copy(beg, end, dest);	// 将元素按逆序拷贝到dest
  ```

- 一些算法同时提供\_copy和\_if版本。这些版本接受一个目的位置迭代器和一个谓词

  ```cpp 
  // 从v1中删除奇数元素
  remove_if(v1.begin(), v1.end(), [](int i){ return i & 0x1 });
  // 将v1中的偶数元素拷贝到v2，v1不变
  remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ return i & 0x1 });
  ```

#### 特定容器算法

- 与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法
- 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法

| list和forward_list成员函数版本的算法       | 说明                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| lst.merge(lst2)<br />lst.merge(lst2, comp) | 将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。合并后，lst2变为空。第一个版本使用<；第二个版本使用给定的比较操作 |
| lst.remove(val)<br />lst.remove_if(pred)   | 调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素    |
| lst.reverse()                              | 反转lst中元素的顺序                                          |
| lst.sort()<br />lst.sort(comp)             | 使用<或给定比较操作对元素进行排序                            |
| lst.unique()<br />lst.unique(pred)         | 调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词 |

- 链表类型还定义了链表数据结构所特有的splice算法(lst.splice(args)或flst.splice_after(args))

| 链表类型splice成员函数的参数 | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| (p, lst2)                    | p是一个指向lst或flst中位置的有效的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表 |
| (p, lst2, p2)                | p2是一个指向lst2中位置的有效的迭代器。将p2指向的元素移动到lst中，或将p2后一个元素移动到flst中。lst2可以是与lst或flst相同的链表 |
| (p, lst2, b, e)              | b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst中p之前的位置或是flst中p之后的位置。lst2可以是与lst或flst相同的链表，但p不能指向给定范围中元素 |

### 关联容器

- 关联容器支持高效的关键字查找和访问
- 两个主要的关联容器类型是map和set
- 标准库提供了8个关联容器，它们之间的不同体现在三个维度上：
  1. map或set
  2. 是否允许重复的关键字(multi)
  3. 是否按顺序保存元素(unordered)

| 关联容器类型       | 说明                                    |
| ------------------ | --------------------------------------- |
| map                | 关联数组；保存键-值对                   |
| set                | 关键字即值，即只保存关键字的容器        |
| multimap           | 关键字可重复的map                       |
| multiset           | 关键字可重复的set                       |
| unordered_map      | 用哈希函数组织的map                     |
| unordered_set      | 用哈希函数组织的set                     |
| unordered_multimap | 用哈希函数组织的、关键字可重复出现的map |
| unordered_multiset | 用哈希函数组织的、关键字可重复出现的set |

- map和multimap定义在头文件map中
- set和multiset定义在头文件set中
- 无序容器定义在头文件unordered_map和unordered_set中

#### 关联容器概述

- 关联容器不支持顺序容器的位置相关的操作
- 关联容器不支持构造函数或插入操作这些接受一个数量值和一个元素值的操作
- 关联容器的迭代器都是双向的

##### 定义关联容器

- 当定义一个map时，必须既指明关键字类型又指明值类型；而定义一个set时，只需指明关键字类型
- 每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器
- 可以将关联容器初始化为另一种同类型容器的拷贝，或是从一个迭代器范围来初始化关联容器，只要这些值能转化为容器所需类型即可
- C++11可以对关联容器进行列表初始化

##### 关键字类型的要求

- 对于有序容器，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字

- 可以提供自己定义的操作来代替关键字上的<运算符，所提供的操作必须在关键字类型上定义一个严格弱序（可看作“小于”）

- 用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。此外，还需要在创建一个容器对象时，以构造函数参数的形式提供比较操作

  ```cpp
  bool compareIsbn(const Sales_data &lhs, const Sales_data &rhd) {
      return lhs.isbn() < rhs.isbn();
  }
  
  multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
  ```

##### pair类型

- pair是一种标准库模板类型，定义在头文件utility中
- pair保存两个public的数据成员，分别名为first和second

| pair上的操作                | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| pair\<T1, T2> p;            | p是一个成员类型为T1和T2的pair，first和second成员都进行了值初始化 |
| pair\<T1, T2> p(v1, v2);    | p是一个成员类型为T1和T2的pair，first和second成员分别用v1和v2进行初始化 |
| pair\<T1, T2> p = {v1, v2}; | 等价于p(v1, v2)                                              |
| make_pair(v1, v2)           | 返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来 |
| p.first                     | 返回first数据成员                                            |
| p.second                    | 返回second数据成员                                           |
| p1 <、>、<=、>= p2          | 关系运算符按字典序定义，关系运算利用元素的<运算符来实现      |
| p1 == p2、p1 != p2          | 当first和second成员分别相等时，两个pair相等。相等性判断利用元素的==运算符实现 |

#### 关联容器操作

| 关联容器额外的类型别名 | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| key_type               | 此容器类型的关键字类型                                       |
| mapped_type            | 每个关键字关联的（值）类型；只适用于map                      |
| value_type             | 对于set，与key_type相同<br />对于map，为pair\<const key_type, mapped_type> |

##### 关联容器迭代器

- 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用
- set的迭代器是const的，set中的关键字也是const的
- 通常不对关联容器使用泛型算法
  - 关联容器不能用于修改或重排容器元素的算法，因为其关键字是const的
  - 关联容器只可用于只读取元素的算法。但是，很多这类算法都要搜索序列，而对关联容器使用泛型搜索算法效率是很低的
  - 在实际编程中，如果我们真要对一个关联容器使用泛型算法，要么是将它作为一个源序列，要么是将它作为一个目的位置

##### 添加元素

| 关联容器的insert操作                   | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| c.insert(v)<br />c.emplace(args)       | v是value_type类型的对象；args用来构造一个元素<br />对于map和set，只有当元素的关键字不在c中时才插入（或构造）元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的bool值<br />对于multimap和multiset，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 |
| c.insert(b, e)<br />c.insert(il)       | b和e是迭代器，表示一个value_type类型值的范围；il是这种值的花括号列表。函数返回void<br />对于map和set，只插入关键字不在c中的元素<br />对于multimap和multiset，则会插入范围中的每个元素 |
| c.insert(p, v)<br />c.emplace(p, args) | 将迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向一个具有给定关键字的元素 |

##### 删除元素

| 从关联容器中删除元素 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| c.erase(k)           | 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量 |
| c.erase(p)           | 从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能等于c.end()。返回一个指向p之后位置的迭代器 |
| c.erase(b, e)        | 删除迭代器b和e所表示的范围中的元素。返回e                    |

##### map的下标操作

| map和unordered_map的下标操作 | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| c[k]                         | 返回k关键字所关联的值；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化 |
| c.at(k)                      | 返回k关键字所关联的值，带参数检查；若k不在c中，抛出一个out_of_range异常 |

- 由于下标运算符可能插入一个新元素，因此只可以对非const的map使用下标操作
- 与vector和string不同，map的下标运算返回的类型与解引用map迭代器得到的类型不同

##### 访问元素

| 在一个关联容器中查找元素的操作 | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| c.find(k)                      | 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器 |
| c.count(k)                     | 返回关键字等于k的元素的数量                                  |
| c.lower_bound(k)               | 返回一个迭代器，指向第一个关键字不小于k的元素                |
| c.upper_bound(k)               | 返回一个迭代器，指向第一个关键字大于k的元素                  |
| c.equal_range(k)               | 返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end() |

- 如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储
- 遍历multimap或multiset中同一关键字的多个元素的方式：
  - c.find(k) + c.count(k)
  - c.lower_bound(k) + c.upper_bound(k)
    - 如果关键字存在，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置
    - 如果关键字不存在，则lower_bound和upper_bound会返回相等的迭代器，指向一个不影响排序的关键字插入位置
  - c.equal_range(k)

#### 无序容器

- 无序容器使用一个哈希函数(hash function)和关键字类型的==运算符来组织元素

- 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素

  - 使用一个哈希函数将元素映射到桶
  - 具有同一个特定哈希值的所有元素都保存在相同的桶中，相同的元素一定具有相同的哈希值
  - 访问一个元素时，容器首先计算元素的哈希值，它指出应该搜索哪个桶

- 无序容器提供了一组管理桶的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组

  | 无序容器的管理操作     | 说明                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | 桶接口                 |                                                              |
  | c.bucket_count()       | 正在使用的桶的数目                                           |
  | c.max_bucket_count()   | 容器能容纳的最多的桶的数量                                   |
  | c.bucket_size(n)       | 下标为n的桶中有多少元素                                      |
  | c.bucket(k)            | 关键字为k的元素在哪个桶中                                    |
  | 桶迭代                 |                                                              |
  | local_iterator         | 可以用来访问桶中元素的迭代器类型                             |
  | const_local_iterator   | 桶迭代器的const版本                                          |
  | c.begin(n), c.end(n)   | 桶n的首元素迭代器和尾后迭代器                                |
  | c.cbegin(n), c.cend(n) | 与前两个函数类似，但返回const_local_iterator                 |
  | 哈希策略               |                                                              |
  | c.load_factor()        | 每个桶的平均元素数量，返回float值                            |
  | c.max_load_factor()    | c试图维护的平均桶大小，返回float值<br />c会在需要时添加新的桶，以使得load_factor <= max_load_factor |
  | c.rehash(n)            | 重组存储，使得bucket_count >= n<br />且bucket_count > size / max_load_factor |
  | c.reserve(n)           | 重组存储，使得c可以保存n个元素且不必rehash                   |

默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型（包括string和智能指针）定义了hash。因此，我们可以直接定义关键字是这些类型的无序容器。但是，我们不能直接定义关键字为自定义类型的无序容器，而必须提供我们自己的hash模板版本。

### 动态内存

- 静态内存用来保存全局对象、局部static对象、类static数据成员；栈内存用来保存局部对象
- 除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间(free store)或堆(heap)
- 堆用来保存动态分配的对象，即在程序运行时分配的对象，动态对象的生存期由程序来控制

#### 动态内存和智能指针

- 动态内存的管理是通过一对运算符来完成的：
  - new，在动态内存中为对象分配空间并返回一个指向该对象的指针
  - delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存
- 为了更容易地使用动态内存，C++11提供了两种智能指针类型来管理动态对象
  - shared_ptr允许多个指针指向同一个对象
  - unique_ptr“独占”所指的对象
  - 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象
  - 以上三种类型都定义在memory头文件中

##### shared_ptr

| shared_ptr和unique_ptr都支持的操作             | 说明                                           |
| ---------------------------------------------- | ---------------------------------------------- |
| shared_ptr\<T> sp<br />unique_ptr\<T> up       | 空智能指针，可以指向类型为T的对象              |
| shared_ptr\<T> sp(q)<br />unique_ptr\<T> up(q) | 调用接受一个内置指针的构造函数进行直接初始化   |
| p                                              | 将p用作一个条件判断，若p指向一个对象，则为true |
| *p                                             | 解引用p，获得它指向的对象的引用                |
| p->mem                                         | 等价于(*p).mem                                 |
| p.get()                                        | 返回p中保存的内置指针                          |
| swap(p, q)<br />p.swap(q)                      | 交换p和q中的指针                               |

| shared_ptr独有的操作  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| make_shared\<T>(args) | 返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象<br />若不传递args，对象会进行值初始化 |
| shared_ptr\<T> p(q)   | p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q                 | p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数 |
| p.unique()            | 若p.use_count()为1，返回true，否则返回false                  |
| p.use_count()         | 返回与p共享对象的智能指针数量；可能很慢，主要用于调试        |

- 可以认为每个shared_ptr都有一个关联的引用计数，用于记录有多少个其他shared_ptr指向相同的对象
- 一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象

##### 直接管理内存

1. 使用new动态分配和初始化对象

   在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针

   ``` cpp
   int *pi = new int;						// 对象进行默认初始化
   int *pi = new int();					// 对象进行值初始化
   int *pi = new int(1024);
   int *ps = new string(10, '9');
   int *pv = new vector<int>{1, 2, 3};
   auto p = new auto(obj);					// p指向一个与obj类型相同的对象，该对象用obj进行初始化
   ```

2. 动态分配的const对象

   对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而且其他类型的对象就必须显式初始化

   ```cpp
   // 分配并初始化一个const int
   const int *pci = new const int(1024);
   // 分配并默认初始化一个const的空string
   const string *pcs = new const string;
   ```

3. 内存耗尽

   一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：

   ```cpp
   // 如果分配失败，new返回一个空指针
   int *p1 = new int;				// 如果分配失败，new抛出std::bad_alloc
   int *p2 = new (nothrow) int;	// 如果分配失败，new返回一个空指针
   ```

   我们称这种形式的new为定位new(placement new)。定位new表达式允许我们向new传递额外的参数，在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。bad_alloc和nothrow都定义在头文件new中。

4. 释放动态内存

   - 为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统
   - delete表达式接受一个指针，指向我们想要释放的对象
   - 传递给delete的指针必须指向动态分配的内存，或者是一个空指针，否则其行为是未定义的
   - 忘记释放动态内存会导致人们常说的“内存泄漏”问题
   - 在delete之后，指针就变成了所谓的空悬指针(dangling pointer)，即指向一块曾经保存数据对象但现在已经无效的内存的指针

##### shared_ptr和new结合使用

- 接受指针参数的智能指针构造函数是explicit的。因此，不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式

  ```cpp
  shared_ptr<int> p1 = new int(1024);		// 错误
  shared_ptr<int> p2(new int(1024));		// 正确
  ```

- 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象

- 永远不要用get初始化另一个智能指针，否则它们是相互独立创建的

| 定义和改变shared_ptr的其他方法               | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| shared_ptr\<T> p(q)                          | p管理内置指针q所指的对象；q必须指向new分配的内存，且能够转换为T*类型 |
| shared_ptr\<T> p(u)                          | p从unique_ptr u那里接管了对象的所有权；将u置为空             |
| shared_ptr\<T> p(q, d)                       | p管理内置指针q所指的对象；q必须指向new分配的内存，且能够转换为T*类型。p将使用可调用对象d来代替delete |
| shared_ptr\<T> p(p2, d)                      | p是shared_ptr p2的拷贝，p将可调用对象d来代替delete           |
| p.reset()<br />p.reset(q)<br />p.reset(q, d) | 若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则将p置为空。若还传递了参数d，将会调用d而不是delete来释放q |

##### 智能指针和异常

- 在使用直接管理内存时，如果在new和delete之间发生异常，且异常未被捕获，则内存就永远不会被释放了
- 如果使用智能指针管理内存，即使所在函数由于异常退出，智能指针也会被销毁，从而释放资源
  - 用智能指针管理那些分配了资源，而又没有定义析构函数来释放这些资源的类对象时，必须传入一个删除器(deleter)完成对指针进行的释放操作
  - 如果使用智能指针管理的资源不是new分配的内存，必须给它传递一个删除器

##### unique_ptr

| unique_ptr操作            | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| unique_ptr\<T> u          | 空unique_ptr，会使用delete来释放它的指针                     |
| unique_ptr\<T, D> u       | 空unique_ptr，会使用一个类型为D的可调用对象来释放它的指针    |
| unique_ptr\<T, D> u(d)    | 空unique_ptr，用类型为D的可调用对象d代替delete               |
| unique_ptr\<T> u(q)       | 用类型为T*的内置指针q初始化u                                 |
| unique_ptr\<T, D> u(q, d) | 用类型为T*的内置指针q初始化u，用类型为D的可调用对象d代替delete |
| u = nullptr               | 释放u指向的对象，将u置为空                                   |
| u.release()               | u放弃对对象的控制权，返回指针，并将u置为空（没有释放对象）   |
| u.reset()<br />u.reset(q) | 释放u指向的对象<br />如果提供了内置指针q，令u指向这个对象；否则，将u置为空 |

- 一个unique_ptr“拥有”它所指的对象。当unique_ptr被销毁时，它所指的对象也被销毁

- 虽然不能对unique_ptr进行拷贝或赋值，但可以通过调用release或reset将对象的所有权从一个非const的unique_ptr转移给另一个unique_ptr

  ```cpp
  unique_ptr<string> p2(p1.release());
  p2.reset(p3.release());
  ```

- 不能拷贝unique_ptr的规则有一个例外：可以拷贝或赋值一个将要被销毁的unique_ptr（例如从函数返回一个unique_ptr）

- 重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象

##### weak_ptr

- weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象
- 将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数

| weak_ptr           | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| weak_ptr\<T> w     | 空weak_ptr，可以指向类型为T的对象                            |
| weak_ptr\<T> w(sp) | 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型 |
| w = p              | p可以是一个shared_ptr或weak_ptr                              |
| w.reset()          | 将w置为空                                                    |
| w.use_count()      | 与w共享对象的shared_ptr的数量                                |
| w.expired()        | 若w.use_count()为0，返回ture，否则返回false                  |
| w.lock()           | 如果w.expired()为true，返回一个空shared_ptr；否则返回一个指向w所指对象的shared_ptr |

#### 动态数组

##### new和数组

1. 初始化动态分配对象的数组

   - 动态数组的大小不必是常量表达式
   - 分配一个动态数组会得到一个指向数组首元素的指针
   - 默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的
   - 可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号
   - C++11还可以提供一个元素的初始化器的花括号列表，但不能在括号中给出初始化器
   - 用new分配一个大小为0的数组是合法的，此时将返回一个合法的非空指针，但此指针不能解引用

   ```cpp
   int *pia = new int[10];							// 默认初始化
   int *pia2 = new int[10]();						// 值初始化
   int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};	// 初始化器
   ```

2. 释放动态数组

   - 数组中的元素按逆序销毁

   - 当释放一个指向数组的指针时，必须在其之前加上空方括号，它指示编译器此指针指向一个对象数组的首元素

     ```cpp
     delete[] pa;	// pa必须指向一个动态分配的数组的首元素或为空
     ```

3. 智能指针和动态数组

   - 标准库提供了一个可以管理动态数组的unique_ptr版本

     | 指向数组的unique_ptr | 说明                                                      |
     | -------------------- | --------------------------------------------------------- |
     | unique_ptr<T[]> u    | u可以指向一个动态分配的数组，数组元素类型为T              |
     | unique_ptr<T[]> u(p) | u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T* |
     | u[i]                 | 返回u拥有的数组中位置i处的对象                            |

   - shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器

     ```cpp
     shared_ptr<int> sp(new int[10], [](int *p){ delete[] p; });
     sp.reset();			// 使用提供的lambda释放数组，它使用delete[]
     ```

   - shared_ptr未定义下标运算符，而且智能指针类型不支持指针的算术运算

     ```cpp
     for (size_t i = 0; i != 10; ++i)
         *(sp.get() + i) = i;		//使用get获取一个内置指针
     ```

##### allocator类

- new存在一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起
- 标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来

| allocator类及其算法            | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| allocator\<T> a                | 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 |
| a.allocate(n)                  | 分配一段原始的、未构造的内存，保存n个类型为T的对象，返回一个指向首个内存单元的指针 |
| a.deallocate(p, n)             | 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy |
| a.construct(p, args)           | p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存单元中构造一个对象 |
| a.destroy(p)                   | p是一个类型为T*的指针，此算法对p指向的对象执行析构函数       |
| uninitialized_copy(b, e, b2)   | 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2开始的原始内存中 |
| uninitialized_copy_n(b, n, b2) | 从迭代器b指向的元素开始，拷贝n个元素到迭代器b2开始的原始内存中 |
| uninitialized_fill(b, e, t)    | 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 |
| uninitialized_fill_n(b, n, t)  | 从迭代器b指向的原始内存开始创建n个对象，对象的值均为t的拷贝  |

## 类的设计者工具

### 拷贝控制

#### 拷贝、赋值与销毁

##### 拷贝构造函数

- 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
- 虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用
- 拷贝构造函数在几种情况下会被隐式地调用。因此，它通常不应该是explicit的
- 与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数
- 一般情况下，合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
- 虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员
- 在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即便如此，拷贝/移动构造函数必须是存在且可访问的

##### 拷贝赋值运算符

- 与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个
- 为了与内置类型的赋值保持一致，赋值运算符通常应该返回一个指向其左侧运算对象的引用

##### 析构函数

- 析构函数负责释放对象使用的资源，并销毁对象的非static数据成员
- 在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁

##### 三/五法则

- 需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符
- 需要拷贝构造函数的类也需要拷贝赋值运算符，反之亦然

##### 使用=default

- 可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成版本
- 当在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的

##### 阻止拷贝

虽然大多数类应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符，但对于某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。

- 定义删除的函数
  - C++11可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝
  - 删除的函数是这样一种函数：虽然声明了它们，但不能以任何方式使用它们
  - 定义方式：在函数的参数列表后面加上=delete
  - =delete必须出现在函数第一次声明的时候
  - 可以对任何函数指定=delete
- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的合成的成员函数将被定义为删除的
- 在C++11发布以前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private且不定义来阻止拷贝的

#### 拷贝控制和资源管理

一般来说，类对象有两种可供选择的拷贝语义：使类的行为看起来像一个值或者像一个指针。

##### 定义行为像值的类

- 如果将一个对象赋予它自身，赋值运算符必须能正确工作（正确处理自赋值）
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

##### 定义行为像指针的类

- 模仿shared_ptr中引用计数机制
- 应该将引用计数保存在动态内存中

#### 交换操作

- 除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数

- 对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap

- 每个调用都应该是swap，而不是std::swap。如果存在类型特定的swap，其匹配程度会优于std::swap

  ```cpp
  using std::swap;
  swap(lhs.h, rhs.h);		// 使用HasPtr版本的swap
  ```

- 可以使用拷贝并交换(copy and swap)技术来定义赋值运算符，这是异常安全的，且能正确处理自赋值

  ```cpp
  HasPtr& HasPtr::operator=(HasPtr rhs) {
      // 交换左侧运算对象和局部变量rhs的内容
      swap(*this, rhs);		// rhs现在指向本对象曾经使用的内存
      return *this;			// rhs被销毁，从而delete了rhs中的指针
  }
  ```

#### 对象移动

C++11支持移动而非拷贝对象，在某些情况下，这会大幅度提升性能。

##### 右值引用

- 为了支持移动操作，C++11引入了右值引用
- 左值引用（常规引用）用于绑定左值，而右值引用用于绑定右值
- 右值引用只能绑定到一个将要销毁的对象（临时对象）。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中
- 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都生成左值
- 返回非引用类型的函数，连同算术、关系、位和后置递增/递减运算符，都生成右值
- 变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
- 可以通过调用std::move来获得绑定到左值上的右值引用
- 调用move就意味着承诺：除了对实参赋值或销毁它外，我们将不再使用它
- 当调用move时，必须绝对确定移后源对象没有其他用户

##### 移动构造函数和移动赋值运算符

- 移动构造函数的第一个引用参数是一个右值引用
- 除了完成资源移动，移动构造函数必须保证移后源对象被销毁是无害的
- 移动赋值运算符执行与析构函数和移动构造函数相同的工作，必须正确处理自赋值
- 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
- 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的
- 依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动
- 更新三/五法则：五个拷贝控制成员应该看做一个整体，一般来说，如果定义了其中任何一个，就应该定义所有五个操作

##### 移动迭代器

- 与一般迭代器不同，移动迭代器的解引用运算符生成一个右值引用
- 通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器
- 由于移动迭代器支持正常的迭代器操作，可以将一对移动迭代器传递给算法。特别是，可以将其传递给uninitialized_copy

##### 右值引用和成员函数

- 除了构造函数和赋值运算符以外，根据实际需要，一个成员函数也可以同时提供拷贝和移动版本
- 拷贝版本接受一个指向const的左值引用，移动版本接受一个指向非const的右值引用
- 可以在参数列表后放置一个引用限定符，可以是&或&&，分别指出this可以指向一个左值或者右值
- 类似于const限定符，引用限定符只能用于非static成员函数，且必须同时出现在函数的声明和定义中
- 一个函数可以同时使用const和引用限定，在此情况下，引用限定符必须跟在const限定符之后
- 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

### 重载运算与类型转换（先略过）

#### 基本概念

#### 输入和输出运算符

#### 算术和关系运算符

#### 赋值运算符

#### 下标运算符

#### 递增递减运算符

#### 成员访问运算符

#### 函数调用运算符

#### 重载、类型转换与运算符

### 面向对象程序设计

#### OOP:概述

面向对象程序设计的核心思想是封装、继承和多态（动态绑定）

#### 定义基类和派生类

##### 定义基类

- 基类必须将它的两种成员函数分开：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数
- 对于基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数（在类内部的声明语句之前加上关键字virtual）
- 当使用基类的引用或指针调用一个虚函数时将发生动态绑定
- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
- 任何构造函数之外的非静态函数都可以是虚函数
- C++11允许使用final关键字来指定某个类不能被继承

##### 定义派生类

- 派生类经常（但不总是）覆盖它继承的虚函数，如果没有覆盖，则会直接继承其在基类中的版本
- 在派生类对象中，除了含有自定义的组成部分外，还含有与其基类对应的组成部分
- 可以把派生类对象当成基类对象来使用，也可以将基类的指针或引用绑定到派生类对象中的基类部分
- 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

##### 类型转换与继承

- 静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
- 动态类型直到运行时才可知，它是变量或表达式表示的内存中的对象的类型
- 基类的指针或引用的静态类型可能与其动态类型不一致
- 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换
- 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉

#### 虚函数

- 当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- 基类中的虚函数在派生类中隐含地也是虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配
- C++11允许使用override关键字来显式地说明我们使用了某个成员函数覆盖了基类中的虚函数，这样可以让编译器为我们发现一些错误
- C++11允许使用final关键字来指定某个函数不能被覆盖
- 如果某次函数调用使用了默认实参，则实参值由本次调用的静态类型决定
- 可以使用作用域运算符来回避虚函数的机制，指定执行虚函数的某个特定版本

#### 抽象基类

- 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数（抽象函数），它的实现留给派生类去做
- 可以通过在类内部的虚函数声明语句处（分号之前）书写=0，将一个虚函数说明为纯虚函数
- 值得注意的是，可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0的函数提供函数体
- 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类，不能（直接）创建一个抽象基类的对象

#### 访问控制与继承

- private成员仅对于本类成员和友元来说是可访问的
- protected成员对于派生类的成员和本类的友元来说是可访问的
- public成员没有访问限制
- 派生访问说明符描述的是派生类的基类部分的访问权限，目的是控制派生类用户（包括派生类的派生类）对基类成员的访问权限
  - 对于公有继承，继承自基类的成员在派生类中的访问说明符不变
  - 对于受保护继承，继承自基类的成员在派生类中的访问说明符降级为protected
  - 对于私有继承，继承自基类的成员在派生类中的访问说明符降级为private
- 派生类向基类转换的可访问性：
  - 当且仅当公有继承时，用户代码才能使用派生类向基类的转换
  - 不论是以什么方式继承，派生类的成员和友元都能使用派生类向基类的转换
  - 如果是公有继承或受保护继承，则派生类的派生类的成员和友元可以使用派生类向基类的类型转换；反之，则不能
- 友元关系不能继承；每个类负责控制各自成员的访问权限
- 如果B是A的友元，B能访问A对象成员，这种可访问性包括了A对象内嵌在其派生类对象中的情况
- 通过使用using声明，可以改变派生类继承的某个名字的访问级别，前提是该名字是派生类可访问的
- struct关键字和class关键字定义的类之间的唯一区别就是默认成员访问说明符及默认派生访问说明符

#### 继承中的类作用域

- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 如果一个名字在派生类的作用域无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义
- 即使静态类型与动态类型可能不一致，但是我们能使用哪些成员仍然是由静态类型决定的
- 派生类能重用定义在其基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字
- 可以通过作用域运算符来使用一个被隐藏的基类成员
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字

![](./images/upgit_20230912_1694510977.png)

#### 构造函数与拷贝控制

##### 虚析构函数

- 基类通常应该定义一个虚析构函数，否则delete一个指向派生类对象的基类指针将产生未定义行为
- 通常，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数是一个重要的例外，即无法推断是否需要
- 基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生一个间接的影响：阻止编译器合成移动操作

##### 合成拷贝控制与继承

- 在继承体系中，合成的拷贝控制成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁
- 在实际编程中，如果在基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作

##### 派生类的拷贝控制成员

- 当派生类定义了拷贝和移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象
- 在默认情况下，基类的默认构造函数初始化对象的基类部分。要想使用别的构造函数，需要在初始值列表中显式地调用该构造函数
- 派生类的赋值操作也必须显式地为其基类部分赋值（调用基类的赋值操作）
- 和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源
- 如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本

##### 继承的构造函数

- 一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数
- 类不能继承默认构造函数和拷贝控制成员，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们，合成版本会用到基类的这些成员
- 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句
- 通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。如果派生类含有自己的数据成员，则这些成员将被默认初始化
- 继承的构造函数的特点(P557)

#### 容器与继承

- 当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容
- 如果要在容器中存放具有继承关系的对象，实际上存放的通常是基类的指针（更好的选择是智能指针）

### 模版与泛型编程

模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。当使用一个泛型类型或者泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。

#### 定义模版

- 模板定义以关键字`template`开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用`<>`包围起来

- 模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（显式地或隐式地）指定模板实参，将其绑定到模板参数上

##### 函数模版

- 当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参

- 模板参数分为类型参数和非类型参数：
  - 类型参数
    - 一般来说，可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用
    - 类型参数前必须使用关键字`class`或`typename`，两者含义相同，但`typename`是后来才引入的
  - 非类型参数
    - 一个非类型参数表示一个值而非一个类型，我们通过一个特定的类型名而非关键字`class`或`typename`来指定非类型参数
    - 在模板定义内，非类型参数是一个常量值，一个常见的用途是指定数组大小
    - 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式
    - 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用
    - 绑定到整型非类型参数的实参必须是一个常量表达式
    - 绑定到指针或引用非类型参数的实参必须具有静态的生存期（不能是动态对象或局部非static对象）
  
  ```cpp
  template <typename T, unsigned size>
  T* begin_def(T (&arr)[size]) {
      return arr;
  }
  
  template <typename T, unsigned size>
  T* end_def(T (&arr)[size]) {
      return arr + size;
  }
  ```
  
- 编写泛型代码的两个重要原则

  - 函数模板的参数是const的引用（保证函数可以用于不能拷贝的类型）
  - 函数体中的条件判断仅使用<比较运算

- 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此模板的头文件通常既包括声明也包括定义

##### 类模板

- 与函数模板不同的是，编译器不能为类模板推断模板实参，我们必须在类模板名后的尖括号中显式提供模板实参列表

- 定义在类模板之外的成员函数必须以关键字`template`开始，后接类模板参数列表

- 成员函数只有在被用到时才进行实例化，由于这一特性的存在，即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类

- 当我们使用一个类模板类型时必须提供模板实参。但在类模板的作用域中，我们可以直接使用模板名而不必指定模板实参

  ```cpp
  template <typename T>
  class Blob {
     public:
      typedef T value_type;
      typedef typename std::vector<T>::size_type size_type;
      // 构造函数
      Blob();
      Blob(std::initializer_list<T> il);
      // 元素数目
      size_type size() const { return data->size(); }
      bool empty() const { return data->empty(); }
      // 添加和删除元素
      void push_back(const T &t) { data->push_back(t); }
      void push_back(T &&t) { data->push_back(std::move(t)); }
      void pop_back();
      // 元素访问
      T& back();
      T& operator[](size_type i);
     private:
      std::shared_ptr<std::vector<T>> data;
      // 若data[i]无效，则抛出msg
      void check(size_type i, const std::string &msg) const;
  };
  
  template <typename T>
  Blob<T>::Blob() : data(std::make_shared<std::vector<T>>()) { }
  
  template <typename T>
  void Blob<T>::check(size_type i, const std::string &msg) const {
      if (i >= data-> size())
          throw std::out_of_range(msg);
  }
  ```

- 一个类可以将另一个模板的每个实例都声明为自己的友元，也可以指定特定的实例为友元

  ```cpp
  // 前置声明，在将模板的一个特定实例声明为友元时要用到
  template <typename T> class Pal;
  
  class C {	// C是一个普通的非模板类
      friend class Pal<C>;	// 用类C实例化的Pal是C的一个友元
      // Pal2的所有实例都是C的友元，无须前置声明
      template <typename T> friend class Pal2;
  };
  
  template <typename T>
  class C2 {	// C2本身是一个类模板
      friend class Pal<T>;	// C2的每个实例将相同实例化的Pal声明为友元
      // Pal2的所有实例都是C的友元，无须前置声明
      template <typename X> friend class Pal2;	// 必须使用与类模板本身不同的模板参数
      // Pal3是一个非模板类，它是C2所有实例的友元,无须前置声明
      friend class Pal3;
  }
  ```

- 在C++11中，可以将模板类型参数声明为友元（允许将内置类型声明为友元）

  ```cpp
  template <typename Type>
  class Bar {
      friend Type;	// 将访问权限授予用来实例化Bar的类型
      // ...
  }
  ```

- C++11允许我们为类模板定义一个类型别名：

  ```cpp
  template <typename T> using twin = pair<T, T>;
  twin<string> authors;	// authors是一个pair<string, string>
  template <typename T> using partNo = pair<T, unsigned>;
  partNo<string> books;	// books是一个pair<string, unsigned>
  ```

- 类模板可以声明static成员

  ```cpp
  template <typename T>
  class Foo {
     public:
      static std::size_t count() { return ctr; }
      // ...
     private:
      static std::size_t ctr;		// 静态数据成员在类内声明
  }
  
  template <typename T>
  std::size_t Foo<T>::ctr = 0;	// 在类外定义并初始化
  ```


##### 模板参数

- 与函数参数相同，声明中的模板参数的名字不必与定义中相同

- 假定`T`是一个模板类型参数，当编译器遇到类似`T::mem`这样的代码时，它不会知道`mem`是一个类型成员还是一个static数据成员

- 默认情况下，C++假定通过作用域运算符访问的名字不是类型

- 如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型（使用关键字`typename`，不能是`class`）

  ```cpp
  template <typename T>
  typename T::value_type top(const T& c) {
      if (!c.empty())
          return c.back();
      else
          return typename T::value_type();
  }
  // top函数期待一个容器类型的实参，它使用typename指明其返回类型，并且在c中没有元素时生成一个值初始化的元素返回给调用者
  ```

- 可以为函数和类模板提供默认模板实参

##### 成员模板

- 一个类可以包含本身是模板的成员函数，这种成员被称为成员模板

- 成员模板不能是虚函数

- 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表

  ```cpp
  template <typename T>
  class Blob {
      template <typename It>
      Blob(It b, It e);
      // ...
  };
  
  template <typename T>
  template <typename It>
  Blob<T>::Blob(It b, It e) : data(std::make_shared<std::vector<T>>(b, e)) { }
  ```

##### 控制实例化

当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个目标文件中。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在C++11中，我们可以通过显式实例化(explicit instantiation)来避免这种开销。

```cpp
// 实例化声明与定义
extern template class Blob<string>;				// 声明
template int compare(const int&, const int&);	// 定义
```

当编译器遇到extern模板声明时，它不会在文件中生成实例化代码。将一个实例化声明为`extern`就表示承诺在程序的其他位置有该实例化的一个非extern声明（实例化定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前。

- 实例化定义会实例化所有成员

  当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。

#### 模板实参推断

##### 类型转换与模板类型参数

- 编译器通常不是对实参进行类型转换，而是生成一个新的模板实例
- 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换以及数组或函数到指针的转换
- 如果函数参数类型不是模板参数，则对实参进行正常的类型转换

##### 函数模板显式实参

在实际应用中，可能会遇到以下两种情况：

①编译器无法推断出模板实参的类型

②我们希望允许用户控制模板实例化

当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。

```cpp
// 编译器无法推断T1，因为它未出现在函数参数列表中
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);

// 提供显式模板实参
auto val = sum<long long>(i, lng);		// long long sum(int, long)
```

- 显式模板实参按由左至右的顺序与对应的模板参数匹配
- 对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换

##### 尾置返回类型与类型转换

当我们希望由用户来确定返回类型时，用显式模板实参表示模板函数的返回类型时很有效的。但在其他情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么好处。例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用：

```cpp
template <typename It>
??? &fcn(It beg, It end) {
    // 处理序列
    return *beg;	// 返回序列中一个元素的引用
}
```

此时，我们并不知道返回结果的准确类型，但知道所需类型是所处理序列的元素类型，此时可以使用尾置返回类型。

```cpp
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg) {
    // 处理序列
    return *beg;	// 返回序列中一个元素的引用
}
```

有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似`fcn`的函数，但返回一个元素的值而非引用。

在这种情况下，我们可以使用标准库的类型转换模板，这些（类）模板定义在头文件`type_traits`中，这个头文件中的类通常用于所谓的“模板元程序设计”，这一主题已超出本书的范围。在本例中，我们可以使用`remove_reference`来获得元素类型。

```cpp
template <typename It>
auto fcn(It beg, It end) -> typename remove_reference<decltype(*beg)>::type {
    // 处理序列
    return *beg;	// 返回序列中一个元素的引用
}
```

![](./images/upgit_20231005_1696496770.png)

##### 函数指针和实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。如果不能从函数指针类型确定模板实参，则产生错误。

```cpp
template <typename T>
int compare(const T&, const T&);

// pf指向实例int compare(const int&, const int&)
int (*pf)(const int&, const int&) = compare;

// func的重载版本，每个版本接受一个不同的函数指针类型
void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare);		// 错误：使用compare的哪个实例？

// 正确：通过使用显式模板实参来消除func调用的歧义
func(compare<int>);		// 传递compare(const int&, const int&)
```

##### 模板实参推断和引用

- 如果一个函数参数的类型是`T&`，只能传递给它一个左值

  ```cpp
  template <typename T> void f1(T&);		// 实参必须是一个左值
  f1(i);		// i是一个int，T是int
  f1(ci);		// ci是一个const int，T是const int
  f1(5);		// 错误：传递给一个&参数的实参必须是一个左值
  ```

- 如果一个函数参数的类型是`const T&`，可以传递给它任何类型的实参

  ```cpp
  template <typename T> void f2(const T&);
  f2(i);		// i是一个int，T是int
  f2(ci);		// i是一个const int，但T是int
  f2(5);		// T是int
  ```

- 如果一个函数参数的类型是`T&&`，可以传递给它任何类型的实参

  - 当传递一个右值时，`T`为该右值的类型，`T&&`为右值引用
  - 当传递一个左值时，`T`为该左值类型的引用，这就间接地创建了一个引用的引用，此时会发生引用折叠，`T&&`为普通左值引用
    - `X& &`、`X& &&`、`X&& &`都折叠成类型`X&`
    - `X&& &&`折叠成`X&&`

  ```cpp
  template <typename T> void f3(T&&);
  f3(42);		// 实参是一个int类型的右值，T是int -> void f3(int&&)
  f3(i);		// i是一个int（左值），T是int& -> void f3(int&)
  f3(ci);		// ci是一个const int（左值），T是const int& -> void f3(const int&)
  ```

模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：

```cpp
template <typename T> void f3(T&& val) {
    T t = val;		// 拷贝还是绑定一个引用？
    t = fcn(t);		// 赋值只改变t还是既改变t又改变val？
    if (val == t) { /* ... */ }		// 若T是引用类型，则一直为true
}
```

在编写接受右值引用参数的模板函数时，如果代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然`remove_reference`这样的类型转换类可能会有帮助）。在实际中，右值引用常用于两种情况：模板转发其实参或模板被重载。

#### 可变参数模板

- 一个可变参数模板就是一个接受可变数目参数的函数模板或类模板

- 可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数

- 我们用一个省略号来指出一个模板参数或函数参数表示一个包

  ```cpp
  // Args是一个模板参数包；rest是一个函数参数包
  template <typename T, typename... Args>
  void foo(const T& t, const Args&... rest);
  
  int i = 0; double d = 3.14; string s = "how now brown cow";
  foo(i, s, 42, d);		// void foo(const int&, const string&, const int&, const double&);
  foo(s, 42, "hi");		// void foo(const string&, const int&, const char[3]&);
  foo("hi");				// void foo(const char[3]&)
  ```

- 可以使用`sizeof...`运算符获取包中元素数目。与`sizeof`类似，`sizeof...`也返回一个常量表达式，且不会对其实参求值

##### 编写可变参数函数模板

可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身。

```cpp
// 用于终止递归并打印最后一个元素的函数
template <typename T>
ostream &print(ostream &os, const T &t) {
    return os << t;
}
// 包中除了最后一个元素之外的其他元素都会调用这个版本的print
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... args) {
    return print(os << t << ", ", args...);
}
```

##### 包扩展

- 对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展(expand)
- 当扩展一个包时，我们还要提供用于每个扩展元素的模式(pattern)
- 扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表
- 我们通过在模式右边放一个省略号(`...`)来触发扩展操作

##### 转发参数包

在C++11中，我们可以组合使用可变参数模板与`forward`机制来编写函数，实现将其实参不变地传递给其他函数。

- 首先，为了保持实参中的类型信息，必须将函数参数定义为模板类型参数的右值引用
- 其次，当转发参数包时，必须使用`std::forward`来保持实参的原始类型

```cpp
class StrVec {
    public:
    template <typename... Args> void emplace_back(Args&&...);
};

template <typename... Args>
inline
void StrVec::emplace_back(Args&&... args) {
    chk_n_alloc();		// 如果需要的话重新分配StrVec内存空间
    alloc.construct(first_free++, std::forward<Args>(args)...);
}
```

可变参数函数模板通常将它们的参数转发给其他函数。这种函数通常具有与上述`emplace_back`函数一样的形式。

#### 模板特例化

一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。

1. 函数模板特例化

   - 当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参，且函数参数类型必须与模板中对应的类型匹配
   - 为了指出我们正在实例化一个模板，应用关键字`template`后跟一个空尖括号`<>`，空尖括号指出我们将为原模板的所有模板参数提供实参
   - 特例化的本质是接管了编译器的工作，实例化一个模板，而非重载它。因此，特例化不影响函数匹配

   ```cpp
   // compare的特殊版本，处理字符数组的指针
   template <>
   int compare(const char* const &p1, const char* const &p2) {		// 一个指向const char的const指针的引用
       return strcmp(p1, p2);
   }
   ```

2. 类模板特例化

   - 特例化类模板（例子见P626）
   - 与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一个部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身仍是一个模板（例子见P628）
   - 我们可以只特例化特定成员函数而不是特例化整个模板（例子见P629）

## 高级主题

### 标准库特殊设施

#### tuple类型

`tuple`是类似`pair`的模板，它可以有任意数量的成员。

| `tuple`支持的操作                            | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| `tuple<T1, T2, ..., Tn> t;`                  | 所有成员都进行值初始化                                       |
| `tuple<T1, T2, ..., Tn> t(v1, v2, ..., vn);` | 每个成员用对应的初始值`vi`进行初始化，此构造函数是`explicit`的 |
| `make_tuple(v1, v2, ..., vn)`                | 返回一个用给定初始值初始化的`tuple`                          |
| `==`、`!=`                                   | 两个`tuple`具有相同数量的成员且成员对应相等时，两个`tuple`相等 |
| `<`、`<=`、`>`、`>=`                         | 两个`tuple`必须具有相同数量的成员                            |
| `get<i>(t)`                                  | 返回`t`的第`i`个数据成员的引用，其左右值属性与`t`相同        |
| `tuple_size<tupleType>::value`               | 一个类模板，可以通过一个`tuple`类型来初始化。它有一个名为`value`的`public constexpr static`数据成员，类型为`size_t`，表示给定`tuple`类型中成员的数量 |
| `tuple_element<i, tupleType>::type`          | 一个类模板，可以通过一个整形常量和一个`tuple`类型来初始化。它有一个名为`type`的`public`类型成员，表示给定`tuple`类型中指定成员的类型 |

#### 随机数（）

在C++11新标准出现之前，C和C++都依赖于一个简单的C库函数`rand`来生成随机数。此函数生成均匀分布的位随机整数，每个随机数的范围在0和某个最大值之间，这个最大值与系统相关。

C++11提供了一个随机数库，定义在头文件`random`中，它主要有两部分组成：

- 随机数引擎类 - 生成随机无符号整数序列。
- 随机数分布类 - 使用引擎类生成指定类型、在给定范围内的、服从特定概率分布的随机数。

> C++程序不应该使用库函数`rand`，而应使用`default_random_engine`类和恰当的分布类对象。

#### IO库再探

##### 格式控制

- 标准库定义了一组操纵符来修改流的格式状态
- 一个操纵符是一个函数或是一个对象，会影响流的状态，并能用作输入或输出运算符的运算对象
- 操纵符用于两大类输出控制：控制数值的输出形式；控制补白的数量和位置
- 大多数改变格式状态的操纵符都是设置/复原成对的：一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原

1. 控制布尔值的格式
   - boolalpha / noboolalpha : 以true或false的形式输出bool值，而非1或0

2. 控制整型值的格式
   - hex : 整型值输出为十六进制
   - oct : 整型值输出为八进制
   - dec : 整型值输出为十进制

   - showbase / noshowbase : 整型值输出带表示进制的前缀
   - setbase(int) : 设置整型值输出为八进制、十六进制或十进制

3. 控制浮点值的格式
   - setprecision(int) : 设置精度（舍入）
   - precision(int) / precision() : 成员函数，前者设置精度并返回旧精度值，后者仅返回旧精度值
   - showpoint / noshowpoint : 总是显示小数点
   - fixed : 浮点值显示为定点十进制
   - scientific : 浮点值显示为科学记数法
   - hexfloat : 浮点值显示为十六进制(C++11)
   - defaultfloat : 重置为默认的浮点值格式(C++11)

   在执行fixed、scientific、hexfloat后，精度值控制的是小数点后面的数字位数，而默认情况下精度值控制的是数字的总位数

4. 控制数值的格式

   - showpos / noshowpos : 对非负数显示+
   - uppercase / nouppercase : 使用大写字母

5. 输出补白

   - setw(int) : 指定下一个数字或字符串值的最小宽度
   - setfill(char) : 指定一个字符代替默认的空白来补白输出

   - left : 左对齐输出，在值的右侧添加填充字符
   - right : 右对齐输出，在值的左侧添加填充字符
   - internal : 左对齐符号，右对齐值，在符号和值之间添加填充字符

6. 控制输入格式

   - skipws / noskipws : 输入运算符跳过空白符（默认）

其中setfill、setprecision、setw、setbase定义在iomanip中

##### 未格式化IO

标准库还提供了一组底层操作，支持未格式化IO，允许我们将一个流当作一个无解释的字节序列来处理。

1. 单字节操作

   | 单字节底层IO操作 | 说明                                      |
   | ---------------- | ----------------------------------------- |
   | is.get(ch)       | 从istream is读取下一个字节存入字符ch中    |
   | os.put(ch)       | 将字符ch输出到ostream os                  |
   | is.get()         | 将is的下一个字节作为int返回               |
   | is.putback(ch)   | 将字符ch放回is                            |
   | is.unget()       | 将is向后移动一个字节                      |
   | is.peek()        | 将下一个字节作为int返回，但不从流中删除它 |

   函数peek和无参的get版本返回一个int的原因是：可以返回文件尾标记。头文件cstdio定义了一个名为EOF的const，我们可以用它来检测从get返回的值是否是文件尾

2. 多字节操作

   多字节操作要求我们自己分配并管理用来保存和提取数据的字符数组。

   | 多字节底层IO操作              | 说明                                                         |
   | ----------------------------- | ------------------------------------------------------------ |
   | is.get(sink, size, delim)     | 从is中读取最多size个字节，并保存在字符数组中，字符数组的起始地址由sink给出。读取过程直至遇到字符delim或读取了size个字节或遇到文件尾时停止。如果遇到了delim，则将其留在输入流中，不读取出来存入sink |
   | is.getline(sink, size, delim) | 与接受三个参数的get版本类似，但会读取并丢弃delim。如果读取不到delim，is将置位failbit |
   | is.read(sink, size)           | 读取最多size个字节，存入字符数组sink中                       |
   | is.gcount()                   | 返回上一个未格式化读取操作从is读取的字节数                   |
   | os.write(source, size)        | 将字符数组source中的size个字节写入os                         |
   | is.ignore(size, delim)        | 读取并忽略最多size个字节，包括delim。与其他未格式化函数不同，ignore有默认参数：size的默认值为1，delim的默认值为文件尾 |

##### 流随机访问

各种流类型通常都支持对流中数据的随机访问。我们可以重定位流，使之跳过一些数据，首先读取最后一行，然后读取第一行，以此类推。标准库提供了一对函数，来定位(seek)到流中给定的位置，以及告诉(tell)我们当前位置。

虽然标准库为所有流类型都定义了seek和tell函数，但它们是否会做有意义的事情依赖于流绑定到哪个设备。在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问。对这些流我们可以调用seek和tell函数，但在运行时会出错，将流置于一个无效状态。

由于istream和ostream类型通常不支持随机访问，所以本节剩余内容只适用于fstream和sstream类型。

为了支持随机访问，IO类型维护了一个标记来确定下一个读写操作要在哪里进行。它们还提供了两个函数：一个函数通过将标记seek到一个一个给定位置来重定位它；另一个函数tell我们标记的当前位置。标准库实际上定义了两对seek和tell函数，一对用于输入流，另一对用于输出流。输入和输出版本的差别在于名字的后缀是g还是p。g版本表示我们正在“获得”数据，而p版本表示我们正在“放置”数据。

| seek和tell函数                         | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| tellg()<br />tellp()                   | 返回一个输入流或输出流标记的当前位置                         |
| seekg(pos)<br />seekp(pos)             | 在一个输入流或输出流中将标记重定位到给定的绝对地址。pos通常是前一个tellg或tellp返回的值 |
| seekp(off, from)<br />seekg(off, from) | 在一个输入流或输出流中将标记定位到from之前或之后off个字符，from可以是下列值之一：<br />- beg，偏移量相对于流开始位置<br />- cur，偏移量相对于流当前位置<br />- end，偏移量相对于流结尾位置 |

编程示例(P678)

#### 正则表达式

正则表达式是一种描述字符序列的方法，是一种极其强大的计算工具。

### 用于大型程序的工具

#### 异常处理

##### 抛出异常

当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。如果在当前函数中找不到，就退出当前的函数，在调用当前函数的外层函数中继续寻找，以此类推。上述过程被称为栈展开(stack unwinding)过程。

- 如果找到了匹配的catch子句，则执行其中的代码，随后找到与try块关联的最后一个catch子句之后的点，从这里继续执行
- 如果没找到匹配的catch子句，程序将退出

在栈展开过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。

##### 捕获异常

- catch子句的异常声明看起来像是只包含一个形参的函数形参列表，实际上其所具有的特性也与函数形参类似
- 最终找到的catch子句未必是异常的最佳匹配，而是首个匹配。因此对catch子句的顺序进行组织和管理尤为重要
- 有时，一个单独的catch语句不能完整地处理某个异常，此时可通过空的throw语句(`thorw;`)重新抛出异常
- 一条捕获所有异常的语句(`catch(...)`)可以与任意类型的异常匹配，它通常与重新抛出语句一起使用

##### 函数try语句块与构造函数

- 构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常

- 处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块

  ```cpp
  template <typename T>
  Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared<std::vector<T>>(il)) {
      /* 空函数体 */
  } catch(const std::bad_alloc &e) {
      handle_out_of_memory(e);
  }
  ```

##### noexcept异常说明

对于用户及编译器来说，预先知道某个函数不会抛出异常大有裨益。首先，这有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。

在C++11中，我们可以通过提供noexcept说明指出某个函数“不会抛出异常”。

- 对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现
- 编译器并不会在编译时检查具有noexcept说明的函数是否真的不会抛出异常
- noexcept说明可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常

noexcept有两层含义：noexcept说明符和noexcept运算符

- noexcept说明符接受一个可选的bool类型实参，该实参指出是否不会抛出异常

- noexcept运算符是一个一元运算符，返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否不会抛出异常

- noexcept说明符的实参常常与noexcept运算符混合使用

  ```cpp
  void f() noexcept(noexcept(g()));	// f和g的异常说明一致
  ```

- 如果一个函数指针是noexcept的，则该指针只能指向noexcept的函数
- 如果一个虚函数是noexcept的，则后续派生出来的虚函数也必须是noexcept的

##### 异常类层次

- exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员（返回一个C风格字符串）
- exception、bad_cast、bad_alloc有默认构造函数
- runtime_error、logic_error没有默认构造函数，但是有一个接受字符串的构造函数，该实参负责提供关于错误的更多信息



![](./images/upgit_20231028_1698467694.png)

#### 命名空间

大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，此时不可避免地会发生某些名字相互冲突的情况。命名空间(namespace)为防止名字冲突提供了可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者以及用户可以避免全局名字固有的限制。

##### 命名空间定义

一个命名空间的定义包含两部分：首先是关键字`namespace`，随后是命名空间名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明和定义就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。

- 每个命名空间都是一个作用域
- 命名空间可以是不连续的
- 尽管命名空间的成员可以定义在命名空间外部，但是这样的定义必须出现在所属命名空间的外层空间
- 模板特例化必须声明在原始模板所属的命名空间中
- 内联命名空间(C++11)
  - 与普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用，无须添加表示该命名空间的前缀
  - 关键字`inline`必须出现在命名空间第一次定义的地方，后续再打开的命名空间是隐式内联的
- 未命名的命名空间
  - 未命名的命名空间中定义的变量具有静态生命周期：它们在第一次使用时创建，并且直到程序结束时才销毁
  - 与其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会跨越多个不同的文件
  - 在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间

##### 使用命名空间成员

- 使用命名空间别名为命名空间设定一个简短的同义词`namespace Qlib = cplusplus_primer::QueryLib;`
- 一条using声明语句一次只引入命名空间的一个成员`using std::cout`
- using指示将命名空间的成员提升到外层作用域中，使得命名空间内所有名字都是可见的`using namespace std`

##### 名字查找

对命名空间内部名字的查找遵循常规的查找规则：

- 由内向外依次查找每个外层作用域，直到最外层的全局命名空间查找过程终止为止
- 对于接受类类型实参的函数来说，其名字查找除了在常规的作用域查找外，还会查找实参类及其基类所属的命名空间

#### 多重继承与虚继承（还没看）

### 特殊工具与技术

#### 控制内存分配

有时候应用程序需要自定义内存分配的细节，比如使用关键字new将对象放置在特定的内存空间中。

##### 重载new和delete

当我们使用一条new表达式时，实际上执行了三步操作：

- 调用一个名为operator new的标准库函数，该函数分配一块足够大、原始的、未命名的内存空间以便存储特定类型的对象
- 运行相应的构造函数以构造这些对象
- 返回一个指向该对象的指针

当我们使用一条delete表达式时，实际上执行了两步操作：

- 对指针所指对象执行对应的析构函数
- 调用一个名为operator delete的标准库函数释放内存空间

应用程序可以在全局作用域中定义operator new函数和operator delete函数，也可以将它们定义为成员函数。

##### 定位new表达式

在C++的早期版本中，allocator类还不是标准库的一部分。应用程序如果想把内存分配与初始化分离开来的话，分配和释放内存空间由operator new和operator delete来实现，而构造和销毁对象则由定位new和显式调用析构函数来实现。

- 定位new允许我们在一个特定的、预先分配的内存地址上构造对象
- 定位new构造对象但是不分配内存
- 定位new的指针甚至不需要指向动态内存

#### 运行时类型识别

运行时类型识别(run-time type identification, RTTI)的功能由两个运算符实现：

- typeid运算符，用于返回表达式的类型
- dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用

当我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数时，可以使用RTTI接管类型管理的重任。

##### dynamic_cast运算符

- dynamic_cast运算符用于向上转型或向下转型
- 如果dynamic_cast转换失败
  - 对于转换目标是指针类型的情况，结果为0
  - 对于转换目标是引用类型的情况，将抛出一个bad_cast异常

```cpp
dynamic_cast<type*>(e);			// e必须是一个有效的指针
dynamic_cast<type&>(e);			// e必须是一个左值
dynamic_cast<type&&>(e);		// e不能是一个左值
```

##### typeid运算符

- typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或其公有派生类型
- typeid运算符可以作用于任意类型的表达式或类型的名字
  - 和往常一样，顶层const被忽略
  - 数组或函数不会转换为指针
- 当运算对象是一个包含虚函数的类类型时，typeid运算符指示的是运算对象的动态类型，否则指示的是运算对象的静态类型

##### type_info类

type_info类的精确定义随着编译器的不同而略有差异，但至少提供以下操作：

| type_info的操作    | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| t1 == t2, t1 != t2 | 判断type_info对象t1和t2是否表示同一种类型                    |
| t.name()           | 返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因编译器而异 |
| t1.before(t2)      | 返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系因编译器而异 |

#### 枚举类型

枚举类型(enumeration)使我们可以将一组整型常量组织在一起，属于字面值常量类型。

1. 枚举类型的定义

   - C++包含两种枚举：限定作用域的(C++11)和不限定作用域的
   - 枚举类型的名字是可选的。如果enum是未命名的，则只能在定义该enum时定义它的对象

   ```cpp
   // 限定作用域的：以enum class开头（或者等价地使用enum struct）
   enum class open_modes {input, output, append};
   // 不限定作用域的：省略掉class（或struct）
   enum color {red, yellow, green};
   ```

2. 枚举成员

   - 在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则
   - 在不限定作用域的枚举类型中，枚举成员的名字的作用域与枚举类型本身的作用域相同
   - 默认情况下，枚举值从0开始，依次加1。可以为枚举成员指定专门的值
   - 枚举成员是const的，在初始化枚举成员时提供的初始值必须是常量表达式。换言之，每个枚举成员本身就是一条常量表达式

   ```cpp
   enum color {red, yellow, green};			// 不限定作用域的枚举类型
   enum stoplight {red, yellow, green};		// 错误：重复定义枚举成员
   enum class peppers {red, yellow, green};	// 正确：枚举成员被隐藏了
   color eyes = green;							// 正确
   peppers p = green;							// 错误：peppers的枚举成员不在有效的作用域中
   peppers p2 = peppers::red;					// 正确
   ```

3. 额外说明

   - 一个不限定作用域的枚举类型对象或枚举成员能够隐式转换成整型

     ```cpp
     int i = color::red;		// 正确
     int j = peppers::red;	// 错误：限定作用域的枚举类型不会进行隐式转换
     ```

   - 在C++11中，可以指定在enum中使用某种整数类型。限定作用域的enum默认是int，不限定作用域的enum没有特定的默认类型

     ```cpp
     enum intValues : unsigned long long {
         charTyp = 255, shortTyp = 65535, intTyp = 65535,
         longTyp = 4294967295UL,
         long_longTyp = 18446744073709551615ULL
     };
     ```

   - 在C++11中，可以提前声明enum，前置声明必须（隐式地或显式地）指定其成员的整数类型

#### 类成员指针

- 成员指针是指可以指向类的非静态成员的指针
- 成员指针的类型囊括了类的类型以及成员的类型
- 当初始化一个成员指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象，直到使用成员指针时，才提供成员所属的对象

##### 数据成员指针

- 定义成员指针

  ```cpp
  // pdata可以指向一个常量（非常量）Screen类型对象的string成员
  const string Screen::*pdata;
  // pada指向某个非特定Screen类型对象的contents成员
  pdata = &Screen::contents;
  ```

- 使用数据成员指针

  ```cpp
  Screen screen, *pScreen = &screen;
  // .*解引用pdata以获得screen对象的contents成员
  auto s = myScreen.*pdata;
  // ->*解引用pdata以获得pScreen所指对象的contents成员
  s = pScreen->*pdata;
  ```

  这些运算符执行两步操作：首先解引用成员指针以得到所需成员，然后像使用普通成员访问运算符那样获取对象中的指定成员。

##### 成员函数指针()

##### 将成员函数用作可调用对象()

#### union: 一种节省空间的类

`union`是一种特殊的类，它可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。

> 当我们给`union`的某个数据成员赋值后，其他数据成员就变成未定义的状态了。因此，当我们使用`union`时，必须清楚地知道当前存储在`union`中的值到底是什么类型。如果我们使用错误的数据成员或者为错误的数据成员赋值，则程序可能崩溃或出现异常行为，具体的情况根据数据成员的类型而有所不同。

- 默认情况下，`union`的成员都是公有的。
- `union`可以定义包括构造函数和析构函数在内的成员函数。
- `union`不能继承自其他类，也不能作为基类使用，因此`union`中不能含有虚函数。

匿名`union`是一个未命名的`union`，不能包含受保护的成员或私有成员，也不能定义成员函数。一旦我们定义了一个匿名`union`，编译器就自动地为该`union`创建一个未命名的对象：

```cpp
union {
    char cval;
    int ival;
    double dval;
};
cval = 'c';
ival = 42;
// 在匿名union的定义所在的作用域内，该union的数据成员都是可以直接访问的。
```

在C++11之前，在`union`中不能含有定义了构造函数或拷贝控制成员的类类型。C++11取消了这一限制。对于含有类类型成员的`union`，当我们将`union`的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。

> 我感觉一个`union`对象本质上就是一段定长的内存空间，我们可以在这段内存空间中反复地写值。
>
> 当我们初始化其中的某个数据成员时，实际上就是在这段内存中进行初始化操作。对于基本数据类型来说，初始化就是简单地写值，这对于编译器来说是很容易实现的；而对于类类型来说，初始化不仅仅是写值，还涉及构造函数的执行，因此需要程序员使用定位`new`表达式来初始化类类型的数据成员。至于销毁某个数据成员，也是类似的道理。

可见，对于`union`来说，要想构造或销毁类类型的数据成员必须执行非常复杂的操作，因此我们通常把含有类类型数据成员的`union`内嵌在一个类中。这个类可以管理并控制与`union`的类类型数据成员有关的状态转换。

> 详见相关章节。

#### 固有的不可移植的特性

##### volatile限定符

- 当对象的值可能在程序的控制流之外被修改时，应该将该对象声明为volatile
- 关键字volatile告诉编译器不应对这样的对象进行优化
- 程序在运行时每次读写这个变量，都会直接从该对象的内存地址中进行读写
- volatile的使用方式跟const很像
- 合成的拷贝对volatile对象无效，因为合成的成员接受的形参类型是（非volatile）常量引用
