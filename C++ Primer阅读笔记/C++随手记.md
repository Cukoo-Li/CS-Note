# C++随手记

## 基础

- 变量表达式是左值。正因如此，decltype((i))和decltype(i)的结果不同

### 函数

- 函数不能定义在另一个函数的内部

- lambda的捕获列表只用于它所在函数中的局部非static变量，对于其他变量，lambda可以直接使用

- bind可以被理解成一个函数适配器，它接收一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表

  ```cpp
  // g是一个有两个参数的可调用对象
  auto g = bind(f, a, b, placeholders::_2, c, placeholders::_1);
  // 生成一个新的可调用对象g，它有两个参数，分别用占位_2和_1表示
  // 传递给g的参数按位置绑定到占位符
  // 调用g(X，Y)会调用f(a, b, Y, c, X)
  ```

## 标准库

- 插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们对一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素
- 通常不对关联容器使用泛型算法
  - 关联容器不能用于修改或重排容器元素的算法，因为其关键字是const的
  - 关联容器只可用于只读取元素的算法。但是，很多这类算法都要搜索序列，而对关联容器使用泛型搜索算法效率是很低的
  - 在实际编程中，如果我们真要对一个关联容器使用泛型算法，要么是将它作为一个源序列，要么是将它作为一个目的位置
- 在手动管理动态内存时，如果在new和delete之间发生异常，且异常未被捕获，则内存就永远不会被释放了。而如果使用智能指针管理动态内存，即使所在函数由于异常推出，智能指针也会被销毁，从而释放资源
- 用new分配一个大小为0的数组是合法的，此时将返回一个合法的非空指针，但此指针不能解引用
- unique_ptr直接支持管理动态数组，支持下标运算
- shared_ptr不直接支持管理动态数组，需要提供自己定义的删除器，但不支持下标运算和算术运算

## 类

### 定义拷贝控制成员

- 析构函数一般都被定义为虚函数
- 拷贝构造函数和拷贝赋值运算符一般是相互依存的，有其一就应有另一
- 需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符
- 可以使用=default来显式地要求编译器生成合成版本
- 可以对任何函数指定=delete。出于实际需求，可以将相应的拷贝控制成员定义为删除的函数
- 大多数拷贝赋值运算符组合了析构函数和拷贝构造函数的工作（释放自身资源、拷贝rhs到自身）
- 除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数
- 可以使用拷贝并交换(copy and swap)技术来定义赋值运算符，这是异常安全的，且能正确处理自赋值

### 移动语义

#### 右值引用

- 左值引用（常规引用）用于绑定左值，而右值引用用于绑定右值
- 右值引用只能绑定到一个将要销毁的对象（临时对象）。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中
- 变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
- 可以通过调用std::move来获得绑定到左值上的右值引用，这意味着承诺：除了对实参赋值或销毁它外，我们将不再使用它

#### 移动构造函数和移动赋值运算符

- 除了完成资源移动，移动构造函数必须保证移后源对象被销毁是无害的
- 移动赋值运算符执行与析构函数和移动构造函数相同的工作，必须正确处理自赋值
- 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
- 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的
- 更新三/五法则：五个拷贝控制成员应该看做一个整体，一般来说，如果定义了其中任何一个，就应该定义所有五个操作
- 依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动

#### 移动迭代器

- 与一般迭代器不同，移动迭代器的解引用运算符生成一个右值引用
- 通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器
- 由于移动迭代器支持正常的迭代器操作，可以将一对移动迭代器传递给算法。特别是，可以将其传递给uninitialized_copy

#### 右值引用和成员函数

- 除了构造函数和赋值运算符以外，根据实际需要，一个成员函数也可以同时提供拷贝和移动版本
- 拷贝版本接受一个指向const的左值引用，移动版本接受一个指向非const的右值引用
- 可以在参数列表后放置一个引用限定符，可以是&或&&，分别指出this可以指向一个左值或者右值
- 类似于const限定符，引用限定符只能用于非static成员函数，且必须同时出现在函数的声明和定义中
- 一个函数可以同时使用const和引用限定，在此情况下，引用限定符必须跟在const限定符之后
- 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

### 类的继承

- C++11允许使用final关键字来指定某个类不能被继承或指定某个函数不能被覆盖
- 对于基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数（在类内部的声明语句之前加上关键字virtual）
- 派生类经常（但不总是）覆盖它继承的虚函数，如果没有覆盖，则会直接继承其在基类中的版本
- 当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
- 即使静态类型与动态类型可能不一致，但是我们能使用哪些成员仍然是由静态类型决定的
- 如果某次函数调用使用了默认实参，则实参值由本次调用的静态类型决定
- C++11允许使用override关键字来显式地说明我们使用了某个成员函数覆盖了基类中的虚函数，这样可以让编译器为我们发现一些错误
- 可以使用作用域运算符来回避虚函数的机制，指定执行虚函数的某个特定版本
- 可以通过在类内部的虚函数声明语句处（分号之前）书写=0，将一个虚函数说明为纯虚函数（也称为抽象函数）
- 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类，不能（直接）创建一个抽象基类的对象
- 通过使用using声明，可以改变派生类继承的某个名字的访问级别，前提是该名字是派生类可访问的
- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 当派生类定义了拷贝和移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象
- 在默认情况下，基类的默认构造函数初始化对象的基类部分。要想使用别的构造函数，需要在初始值列表中显式地调用该构造函数
- 析构函数只负责销毁派生类自己分配的资源
- 一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数
- 类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们
- 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句

## 代码风格指南

- 如果不需要改变实参，尽量使用常量引用作为形参，常量引用能接收的实参类型更广泛