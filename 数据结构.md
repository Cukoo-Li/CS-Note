# 数据结构

## 绪论



## 线性表

线性表是具有相同数据类型的n个数据元素的有限序列

### 顺序表

#### 顺序表的定义

- 顺序表是以顺序存储方式实现的线性表
- 用一组地址连续的存储单元依次存储线性表中的数据元素
- 表中元素的逻辑顺序与其物理顺序相同

#### 顺序表上基本操作的实现

- 查找：顺序查找给定元素，并返回其位序

- 插入：找到要删除的位置，将当前位置及其后元素依次往后移动一个位置，腾出空位插入新元素
- 删除：找到要删除的位置，将当前位置以后得元素依次往前移动一个位置

### 链表

#### 单链表

- 单链表是以链式存储方式实现的线性表
- 用一组任意的存储单元来存储线性表中的数据元素
- 对每个结点，除存放元素本身的信息外，还存放一个指向其后继的指针next
- 通常用头指针来表示一个单链表
- 为了操作上的方便，一般设置一个不存储信息的头结点

#### 单链表上基本操作的实现

1. 创建
   - 头插法：将读取到的结点依次插在头结点之后（简单、逆序）
   - 尾插法：将读取到的结点依次插在表尾，为此必须增加一个始终指向表尾的尾指针（顺序）
2. 查找
   - 按位查找：顺着next指针遍历链表，直到找到第i个结点为止，返回指向该结点的指针，否则返回NULL
   - 按值查找：顺着next指针遍历链表，直到找到值为给定值的结点为止，返回指向该结点的指针，否则返回NULL
3. 插入
   - 后插：找到待插入位置的前驱结点，即第i-1个结点，在其后插入新结点
   - 前插：先后插，再交换数据域
4. 删除
   - 直接删除：找到被删结点的前驱结点，将其next指向被删结点的下一结点，释放被删结点的存储空间
   - 间接删除：找到被删结点，将其后继结点的值赋予其自身，然后删除后继结点

#### 双链表

- 为克服单链表只能单向顺序访问的缺点，引入双链表
- 双链表的结点中有两个指针prior和next，分别指向其前驱结点和后继结点

#### 循环链表

1. 循环单链表
   - 表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环
   - 判空条件不是头结点的指针是否为空，而是它是否等于头指针
   - 因为循环单链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾
   - 有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高
2. 循环双链表
   - 与循环单链表相比，循环双链表头结点的prior指针还要指向表尾结点

#### 静态链表

- 静态链表是数组形式的链表，占用是一块连续的存储空间
- 结点也由数据域和指针域构成，但这里的指针是后继结点的相对地址（数组下标），又称游标
- 静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言中，这是一种非常巧妙的设计方法

#### 顺序表和链表的比较

- 存取方式
- 逻辑结构与物理结构
- 查找、插入和删除操作
- 空间分配

## 栈、队列和数组

### 栈

#### 栈的基本概念

- 栈是只允许在一端进行插入或删除操作的线性表
- 栈的操作特性是后进先出
- n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^{n}$（卡特兰数）

#### 栈的顺序存储

- 利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针top指示当前栈顶元素的位置
- 可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸

#### 栈的链式存储

- 链栈一般采用单链表实现，并规定所有操作都是在单链表的表头进行的
- 链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满且产生上溢的问题

### 队列

#### 队列的基本概念

- 队列是一种只允许在一端进行插入、在另一端进行删除的线性表
- 队列的操作特性是先进先出

#### 队列的顺序存储

- 利用一组地址连续的存储单元存放队列中的元素，并附设两个指针：front指向队头元素，rear指向队尾元素的下一个位置
- 一般将顺序队列从逻辑上视为一个环，称为循环队列
  - 初始时：Q.front=Q.rear=0
  - 队首指针进1：Q.front=(Q.front+1)%MaxSize
  - 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize
  - 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize
  - 判空条件：Q.front==Q.rear
  - 判满条件：
    - 牺牲一个单元来区分队空和队满，以“队头指针在队尾指针的下一位置”作为队满的标志
    - 增设size数据成员，用于记录元素个数
    - 增设tag数据成员，用于记录上一次增删操作的类型

#### 队列的链式存储

- 链队列实际上是一个同时带有队头指针和队尾指针的单链表
- 链队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题

#### 双端队列

- 双端队列是指允许两端都可以进行入队和出队操作的队列
- 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列
- 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列

### 栈和队列的应用

- 栈在括号匹配中的应用
- 栈在表达式求值中的应用
- 栈在递归中的应用
- 队列在层次遍历中的应用
- 队列在计算机系统中的应用

### 数组和特殊矩阵

特殊矩阵具有许多相同元素或零元素，且这些相同元素或零元素的分布有一定的规律性。可以根据这种规律性，把二维数组中的信息压缩存储到一维数组中。只需确定二维数组中的元素下标和一维数组中的元素下标之间的对应关系，就能实现两者之间的转换。

## 串

### 串的定义与实现

#### 串的定义

- 串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集
- 线性表的操作主要以单个元素作为操作对象，而串的操作通常以子串作为操作对象

#### 串的存储结构

- 定长顺序存储表示
- 堆分配存储表示
- 块链存储表示

#### 串的基本操作

串赋值、串比较、求串长、串联接、求子串、串清除、串销毁...

### 串的模式匹配

串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置

#### 朴素模式匹配算法

- 穷举、暴力匹配
- 时间复杂度为O(nm)

#### KMP算法

- 利用部分匹配产生的信息，可以求出next数组
- next[j]的含义是：在模式串的第j个字符与主串发生失配时，跳到子串的next[j]位置重新与主串当前位置进行比较
- 借助next数组，可以实现主串指针不回溯，时间复杂度为O(n+m)

## 树与二叉树

### 树的基本概念

#### 树的定义

树是n个结点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：

- 有且仅有一个根结点
- 当n>1时，其余结点可分为m个互不相交的有限集T~1~,T~2~,...,T~m~，其中每个集合本身又是一棵树，称为根的子树

显然，树的定义是递归的，树是一种递归的数据结构。

#### 基本术语

- 树中一个结点的孩子个数称为结点的度，树中结点的最大度数称为树的度
- 度大于0的结点称为分支节点，度为0的结点称为叶子结点
- 树的高度（或深度）是树中结点的最大层数
- 根据树中结点的各子树从左到右是否有次序、不能互换，可分为有序树和无序树
- 树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，路径长度是路径上所经过的边的个数
- 森林是m棵互不相交的树的集合

#### 树的性质

- 结点总数 = 所有结点的度数之和 + 1
- 度为m的树中第i层上至多有m^i-1^个结点
- 高度为h的m叉树至多有(m^h^-1)/(m-1)个结点
- 具有n个结点的m叉树的最小高度为[log~m~(n(m-1)+1)]

### 二叉树的概念

#### 二叉树的定义及其主要特性

1. 二叉树的定义
   - 二叉树是每个结点至多只有两棵子树的有序树（即使树种结点只有一棵子树，也要区分它是左子树还是右子树）
   - 二叉树是n个结点的有限集合：
     - 或者为空二叉树，即n=0
     - 或者由一个根结点和两个互不相交的左子树和右子树组成
2. 几个特殊的二叉树
   - 满二叉树：树中的每层都含有最多的结点
     - 可以对满二叉树按层序编号，自上而下，从左到右，每个结点对应一个编号
     - 对于编号为i的节点，双亲为[i/2]，左孩子为2i，右孩子为2i+1
   - 完全二叉树：每个结点都与满二叉树的编号一一对应
     - 若i<=[n/2]，则结点i为分支结点，否则为叶子结点
     - 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点只有左孩子，没有右孩子
   - 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字
   - 平衡二叉树：树上任一结点的左子树和右子树的深度只差不超过1
3. 二叉树的性质
   - 非空二叉树上的叶子结点数等于度为2的结点数加1，即n~0~=n~2~+1
   - 结点i所在层次（深度）为[log~2~i]+1
   - 具有n个结点的完全二叉树的高度为[log~2~(n+1)]或[log~2~n]+1

#### 二叉树的存储结构

1. 顺序存储结构
   - 将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的位置
   - 可以利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系
   - 仅适用于完全二叉树，用于非完全二叉树会造成存储空间的浪费
2. 链式存储结构
   - 二叉链表至少包含3个域：数据域data、左指针域lchild、右指针域rchild
   - 在含有n个结点的二叉链表中，含有n+1个空链域

### 二叉树的遍历和线索二叉树

#### 二叉树的遍历

按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序、中序和后序三种，其中“序”指的是根结点在何时被访问。

1. 先序遍历

   ```cpp
   void PreOrder(BiTree T) {
       if (T != nullptr) {
           visit(T);
           PreOrder(T->lchild);
           PreOrder(T->rchild);
       }
   }
   ```

2. 中序遍历

   ```cpp
   void InOrder(BiTree T) {
       if (T != nullptr) {
           PreOrder(T->lchild);
           visit(T);
           PreOrder(T->rchild);
       }
   }
   ```

3. 后序遍历

   ```cpp
   void PostOrder(BiTree T) {
       if (T != nullptr) {
           PreOrder(T->lchild);
           PreOrder(T->rchild);
           visit(T);
       }
   }
   ```

4. 递归算法和非递归算法的转换

   在先序、中序和后序遍历中，三者走过的路径都是相同的，区别在于它们分别在第一次、第二次和第三次经过结点时访问该结点。

   借助栈，可以写出先序、中序、后序遍历的非递归算法：

   - 中序遍历

     ①沿着根的左孩子，依次入栈，直到左孩子为空

     ②栈顶元素出栈并访问：若其右孩子为空，继续执行②；若其右孩子不为空，将右子树转执行①

     ```cpp
     void InOrder2(BiTree T) {
         InitStack(S);				// 初始化栈
         BiTree p = T;				// p是遍历指针
         while (p || !IsEmpty(S)) {
             if (p) {				// 一路向左
                 Push(S, p);
                 p = p->lchild;
             } else {				// 出栈，并转向出栈结点的右子树
                 Pop(S, p);
                 visit(p);
                 p = p->rchild
             }
         }
     }
     ```

   - 先序遍历

     先序遍历和中序遍历的思想基本一致，只需把访问结点操作放在入栈操作之前。

   - 后序遍历

     后序遍历是最难的。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子之前被访问，才能访问根结点。

5. 层次遍历

   要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点。若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，访问出队结点……如此反复，直至队列为空。

6. 由遍历序列构造二叉树

   - 由先序序列和中序序列可以唯一确定一棵二叉树
   - 由后续序列和中序序列可以唯一确定一棵二叉树
   - 由层序序列和中序序列可以唯一确定一棵二叉树

#### 线索二叉树（难）

1. 线索二叉树的基本概念

   - 遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，产生结点之间的前驱和后继关系
   - 传统的二叉链表仅能体现父子关系，不能直接得到结点在遍历中的前驱或后继
   - 在含n个结点的二叉树中，有n+1个空链域，考虑利用这些空链域来存放其前驱或后继的指针
     - 若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点
     - 增加两个标志域标识指针域是指向左右孩子还是指向前驱后继
     - 线索二叉树的结点结构：lchild, ltag, data, rtag, rchild

2. 中序线索二叉树的构造

   二叉树的线索化是将二叉链表中的空链域改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树。

   ```cpp
   void InThred(ThreadTree &p, ThreadTree &pre) {
       if (p != nullptr) {
           InThread(p->lchild, pre);
           if (p->lchild == nullptr) {
               p->lchild = pre;
               p->ltag = 1;
           }
           if (pre && pre->rchild == nullptr) {
               pre->rchild = p;
               pre->tag = 1;
           }
           pre = p;
           InThread(p->rchild, pre)
       }
   }
   
   void CreateInThread(ThreadTree T) {
       ThreadTree pre = nullptr;
       if (T != nullptr) {
           InTread(T, pre);
           pre->rchild = nullptr;		// 处理遍历的最后一个结点
           pre->rtag = 1;
       }
   }
   ```

3. 中序线索二叉树的遍历

   在中序线索二叉树中找结点后继的规律是：若其右标志位为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树最左下的结点）为其后继。

   1. 求中序线索二叉树的第一个结点：

      ```cpp
      ThreadNode *Firstnode(ThreadNode *p) {
          while (p->ltag == 0) p = p->lchild;		// 最左下结点（不一定是叶子结点）
          return p;
      }
      ```

   2. 求中序线索二叉树中结点p的后继：

      ```cpp
      ThreadNode *Nextnode(ThreadNode *p) {
          if (p->rtag==0) return Firstnode(p->rchild);	// 右子树最左下结点（不一定是叶子结点）
          else return p->rchild;
      }
      ```

   3. 利用上面两个算法，可以写出中序线索二叉树中的中序遍历的算法：

      ```cpp
      void Inorder(ThreadNode *T) {
          for (ThreadNode *p = Firstnode(T); p != nullptr; p = Nextnode(p)) {
              visit(p);
          }
      }
      ```

4. 先序线索二叉树和后序线索二叉树

   建立先序线索二叉树和后序线索二叉树的代码与建立中序线索二叉树类似，只需变动线索化改造的代码段(visit)与调用线索化左右子树递归函数的位置。

   如何在先序线索二叉树中找结点的后继？如果有左孩子，则左孩子就是其后继；如果无左孩子，但有右孩子，则右孩子就是其后继；如果为叶子结点，则右链域直接指示了其后继。

   在后序线索二叉树中找结点的后继较为复杂，可分3种情况：①若结点x是二叉树的根，则其后继为空；②若结点x是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲；③若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列岀的第一个结点。可见在后序线索二叉树上找后继时需知道结点双亲，即需采用带标志域的三叉链表作为存储结构。

### 树、森林

#### 树的存储结构

1. 双亲表示法

   采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。该存储结构可以很快得到每个结点的双亲，但求结点的孩子时需要遍历整个结构。

   ![image-20230912183241236](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230912_1694514761.png)

2. 孩子表示法

   将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表。这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个孩子链表。

   ![image-20230912200119835](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230912_1694520081.png)

3. 孩子兄弟表示法（二叉树表示法）

   每个结点包括三部分内容：结点值、指向第一个孩子的指针、指向右兄弟的指针，从而使得一般的树转换为二叉树。

   ![image-20230912203449233](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230912_1694522089.png)

#### 树、森林与二叉树的转换

树转换为二叉树的规则：“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。

树转换为二叉树的画法：①将兄弟结点连起来；②对每个结点，只保留它与第一个孩子的连线；③以树根为轴心，顺时针旋转45°。

将森林转换为二叉树的规则：先将森林中的每棵树转换为二叉树，再把每棵树的根结点视为兄弟结点，依次连接。

![image-20230912211411455](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230912_1694524451.png)

#### 树和森林的遍历

1. 树的遍历

   - 先根遍历：先访问根结点，再依次遍历根结点的每棵子树。其遍历序列与这棵树相应二叉树的先序序列相同。
   - 后根遍历：先依次遍历根结点的每棵子树，再访问根结点。其遍历序列与这棵树相应二叉树的中序序列相同。
   - 层次遍历：与二叉树的层次遍历思想基本相同，借助队列实现。

2. 森林的遍历

   - 先序遍历
     - 访问第一棵树的根结点
     - 先序遍历第一棵树的根结点的子树森林
     - 先序遍历除去第一棵树之后剩余的树构成的森林
   - 中序遍历
     - 中序遍历第一棵树的根结点的子树森林
     - 访问第一棵树的根结点
     - 中序遍历除去第一棵树之后剩余的树构成的森林

   当森林转换成二叉树时，其第一棵树的子树森林转换成左子树，剩余树的森林转换成右子树，可知森林的先序和中序遍历即为对应二叉树的先序和中序遍历。

### 哈夫曼树和哈夫曼编码

1. 哈夫曼树的定义

   - 在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权
   - 从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度
   - 树中所有叶结点的带权路径长度之和称为该树的带权路径长度
   - 在含有n个带权叶结点的二叉树中，其中带权路径长度最小的二叉树称为哈夫曼树，也称最优二叉树

2. 哈夫曼树的构造

   给定n个带权结点，构造哈夫曼树的算法描述如下：

   ①将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F

   ②构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左右子树，并将新结点的权值置为左右子树根结点的权值之和

   ③从F中删除刚才选出的两棵树，同时将新得到的树加入F中

   ④重复步骤②和③，直至F中只剩下一棵树为止

   ![image-20230917201130113](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230917_1694952692.png)

   从上述构造过程可以看出哈夫曼树具有如下特点：

   - 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
   - 构造过程中共新建了n-1个（双分支）结点，因此哈夫曼树的结点总数为2n-1
   - 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点

3. 哈夫曼编码

   利用哈夫曼树可以设计出总长度最短的二进制前缀编码（没有一个编码是另一个编码的前缀）

   ①将每个出现的字符当作一个独立的结点，其权值为它出现的频度，构造出对应的哈夫曼树

   ②将字符的编码解释为从根至字符的路径上边标记的序列

   ![image-20230917202017777](https://raw.githubusercontent.com/Cukoo-Li/typora-photos/main/2023/09/upgit_20230917_1694953217.png)

## 图

### 图的基本概念

#### 图的定义

图G由顶点集V和边集E组成，记为G=(V,E)。其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={v~1~,v~2~,…,v~n~}，则用|V|表示图G中顶点的个数，E={(u,v)|u∈V,v∈V}，用|E|表示图G中边的条数。

1. 有向图

   若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v,w>，v称为弧尾，w称为弧头，<v,w>称为从v到w的弧，也称v邻接到w。

2. 无向图

   若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为(v,w)或(w,v)。可以说v和w互为邻接点。边(v,w)依附于w和v，或称边(v,w)和v,w相关联。

3. 简单图、多重图

   一个图G如果满足：①不存在重复边；②不存在顶点到自身的边，那么称图G为简单图。若图G中某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身关联，则称图G为多重图。多重图和简单图的定义是相对的。数据结构中仅讨论简单图。

4. 完全图（也称简单完全图）

   任意两个顶点之间都存在边的无向图称为无向完全图；任意两个顶点之间都存在方向相反的两条弧的无向图称为无向完全图。

5. 子图

   设有两个图G=(V,E)和G'=(V',E')，若V‘是V的子集，且E'是E的子集，则称G'是G的子图。若有满足V(G')=V(G')的子图G'，则称其为G的生成子图。

6. 连通、连通图、连通分量

   在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。

7. 强连通图、强连通分量

   在有向图中，如果有一对顶点v和w,从v到w和从w到v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量

8. 生成树、生成森林

   连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林

9. 顶点的度、入度和出度

   在无向图中，顶点v的度是指依附于顶点v的边的条数，记为TD(v)。在有向图中，顶点v的度分为入度和出度，入度是以顶点v为终点的有向边的数目，记为ID(v)；而出度是以顶点v为起点的有向边的数目，记为OD(v)

10. 带权图

    在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。

11. 稠密图、稀疏图

    边数很少的图称为稀疏图，反之称为稠密图。稀疏图和稠密图常常是相对而言的。

12. 路径、路径长度和回路

    路径是指两个顶点之间所经过的顶点序列，当然关联的边也可理解为路径的构成要素。路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有n个顶点，并且有大于n-1条边，则此图一定有环。

13. 简单路径、简单回路

    在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点歪，其余顶点不重复出现的回路称为简单回路。

14. 距离

    从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷(∞)。

15. 有向树

    一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。
